<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Sail的日记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Sail的日记本">
<meta property="og:url" content="http://woodensail.github.io/page/2/index.html">
<meta property="og:site_name" content="Sail的日记本">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sail的日记本">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Sail的日记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Sail</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/woodensail" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JVM/" style="font-size: 12px;">JVM</a> <a href="/tags/JavaScript/" style="font-size: 12px;">JavaScript</a> <a href="/tags/PythonChallenge/" style="font-size: 10px;">PythonChallenge</a> <a href="/tags/bootstrap/" style="font-size: 12px;">bootstrap</a> <a href="/tags/ip/" style="font-size: 10px;">ip</a> <a href="/tags/j2ee/" style="font-size: 10px;">j2ee</a> <a href="/tags/jQuery/" style="font-size: 12px;">jQuery</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/javaScript/" style="font-size: 14px;">javaScript</a> <a href="/tags/keygen/" style="font-size: 10px;">keygen</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/rsa/" style="font-size: 10px;">rsa</a> <a href="/tags/加密/" style="font-size: 10px;">加密</a> <a href="/tags/数据分析/" style="font-size: 18px;">数据分析</a> <a href="/tags/每日一题/" style="font-size: 14px;">每日一题</a> <a href="/tags/游戏/" style="font-size: 12px;">游戏</a> <a href="/tags/练习/" style="font-size: 16px;">练习</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Sail</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Sail</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/woodensail" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-bootstrap-magicsuggest-e6-8f-92-e4-bb-b6-e4-bf-ae-e6-94-b9-ef-bc-8c-e9-98-b2-e6-ad-a2-e6-8e-a7-e4-bb-b6-e5-88-9d-e5-a7-8b-e5-8c-96-e6-97-b6-e4-b8-a2-e5-a4-b1-e5-b1-9e-e6-80-a7-e3-80-82" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/08/bootstrap-magicsuggest-e6-8f-92-e4-bb-b6-e4-bf-ae-e6-94-b9-ef-bc-8c-e9-98-b2-e6-ad-a2-e6-8e-a7-e4-bb-b6-e5-88-9d-e5-a7-8b-e5-8c-96-e6-97-b6-e4-b8-a2-e5-a4-b1-e5-b1-9e-e6-80-a7-e3-80-82/" class="article-date">
  	<time datetime="2015-04-08T09:26:10.000Z" itemprop="datePublished">2015-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/08/bootstrap-magicsuggest-e6-8f-92-e4-bb-b6-e4-bf-ae-e6-94-b9-ef-bc-8c-e9-98-b2-e6-ad-a2-e6-8e-a7-e4-bb-b6-e5-88-9d-e5-a7-8b-e5-8c-96-e6-97-b6-e4-b8-a2-e5-a4-b1-e5-b1-9e-e6-80-a7-e3-80-82/">bootstrap-MagicSuggest插件修改，防止控件初始化时丢失属性。</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>与之前常用的easyui不同，MagicSuggest没有将原始标签设为hidden，并作为访问入口的方式。而是选择用新标签替换原始表签，同时将原标签的id和style复制过来，这样带来的缺点是，在对象初始化时，原标签所绑定的属性和事件会丢失。<br>下面就是对MagicSuggest进行修改，将原始标签所有属性复制入新标签中。此处没有处理事件，因为我暂时不需要。<br>第一处是遍历原标签属性，其中2,4行为原有，我增加了1,3行，将所有属性并入attrivutes中，而不是直接置入def，防止混淆。<br>第二处是通过extend方法将原来的属性和cfg.attributes合并后赋给新标签。<br>[javascript]<br>def.attributes = {};<br>$.each(this.attributes, function (i, att) {<br>    def.attributes[att.name] = att.value;<br>    def[att.name] = att.name === ‘value’ &amp;&amp; att.value !== ‘’ ? JSON.parse(att.value) : att.value;<br>});</p>
<p>ms.container = $(‘&lt;div/&gt;’, $.extend(true, {}, cfg.attributes, /<em> 原代码 </em>/));<br>[/javascript]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bootstrap/">bootstrap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaScript/">javaScript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-bootstrap-magicsuggest-e6-8f-92-e4-bb-b6-e4-bf-ae-e6-94-b9-ef-bc-8c-e4-b8-ba-e8-87-aa-e5-8a-a8-e5-ae-8c-e6-88-90-e5-8a-9f-e8-83-bd-e5-a2-9e-e5-8a-a0-e5-a4-9a-e5-ad-97-e6-ae-b5-e5-92-8c-e5-9b-9e" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/08/bootstrap-magicsuggest-e6-8f-92-e4-bb-b6-e4-bf-ae-e6-94-b9-ef-bc-8c-e4-b8-ba-e8-87-aa-e5-8a-a8-e5-ae-8c-e6-88-90-e5-8a-9f-e8-83-bd-e5-a2-9e-e5-8a-a0-e5-a4-9a-e5-ad-97-e6-ae-b5-e5-92-8c-e5-9b-9e/" class="article-date">
  	<time datetime="2015-04-08T08:15:04.000Z" itemprop="datePublished">2015-04-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/08/bootstrap-magicsuggest-e6-8f-92-e4-bb-b6-e4-bf-ae-e6-94-b9-ef-bc-8c-e4-b8-ba-e8-87-aa-e5-8a-a8-e5-ae-8c-e6-88-90-e5-8a-9f-e8-83-bd-e5-a2-9e-e5-8a-a0-e5-a4-9a-e5-ad-97-e6-ae-b5-e5-92-8c-e5-9b-9e/">bootstrap-MagicSuggest插件修改，为自动完成功能增加多字段和回调支持</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>MagicSuggest中的自动完成功能只支持单字段搜索，我增加了一个filter字段，并对<em>sortAndTrim方法进行修改，从而达成多字段以及通过回调实现自动完成功能。<br>实现时使用了lodash库，如果filter为数组，根据filter数组中所指定的字段进行筛选。否则视为函数，将目前输入内容q和一条记录所对应的对象obj作为参数执行filter。返回true则判断符合，反之不符合。<br>[javascript]<br>if(cfg.filter!==null) {<br>    if (</em>.isArray(cfg.filter)) {<br>        if(cfg.strictSuggest) {<br>            filtered = <em>.filter(data, function (obj) {<br>                return </em>.any(<em>.pick(obj, cfg.filter), function (v) {<br>                    return v.indexOf(q) === 0<br>                });<br>            });<br>        }else {<br>            filtered = </em>.filter(data, function (obj) {<br>                return <em>.any(</em>.pick(obj, cfg.filter), function (v) {<br>                    return v.indexOf(q) &gt; -1<br>                });<br>            });<br>        }<br>    } else {<br>        $.each(data, function (index, obj) {<br>            if (cfg.filter(q, obj)) {<br>                filtered.push(obj);<br>            }<br>        });<br>    }<br>}else{<br>    //原来的代码<br>}<br>[/javascript]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bootstrap/">bootstrap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaScript/">javaScript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s106-ef-bc-9a-e5-be-ae-e4-bf-a1-e8-90-a5-e8-bf-90-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/07/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s106-ef-bc-9a-e5-be-ae-e4-bf-a1-e8-90-a5-e8-bf-90-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90/" class="article-date">
  	<time datetime="2015-04-07T02:23:11.000Z" itemprop="datePublished">2015-04-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/07/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s106-ef-bc-9a-e5-be-ae-e4-bf-a1-e8-90-a5-e8-bf-90-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90/">数据分析S106：微信营运数据分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>主要任务提取出每篇文章所造成的影响，并且合并同类文章后，显示每类文章造成的影响。<br>[python]<br>df = pd.ExcelFile(r&quot;resource/wxgzhdata.xlsx&quot;).parse(u&quot;3月&quot;)<br>prev = []<br>articles={}<br>titles=[]<br>for i in df.as_matrix():<br>    prev = [i[j]+prev[j-1] for j in range(1,5)] if prev else [i[j] for j in range(1,5)]<br>    prev.append(i[6])<br>    if not isinstance(i[6],float):<br>        title=i[6][:2]<br>        if title not in titles:<br>            titles.append(title)<br>            articles[title]=prev<br>            prev=None<br>        else:<br>            for i in range(4):<br>                articles[title][i]+=prev[i]<br>            for i in range(len(articles[title][4])):<br>                if articles[title][4][i]!=prev[4][i]:<br>                    break<br>            else:<br>                i+=1<br>            articles[title][4]=prev[4][:i]<br>            prev=None<br>articles={i[4]:[i[0],i[1],i[2],i[3]] for i in articles.values()}<br>df2=pd.DataFrame(articles).rename({0:’总阅读’,1:’初次打开阅读’,2:’分享次数’,3:’增粉数’})<br>df2.plot(kind=’bar’)<br>df2.T.plot(kind=’barh’)<br>from pylab import mpl<br>mpl.rcParams[‘font.sans-serif’] = [‘SimHei’] # 指定默认字体<br>mpl.rcParams[‘axes.unicode_minus’] = False # 解决保存图像是负号’-‘显示为方块的问题<br>plt.show()<br>[/python]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据分析/">数据分析</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s104-ef-bc-9a-e5-88-86-e6-9e-90-e7-94-a8-e6-88-b7-e5-8f-91-e8-a8-80-e5-9c-a8-e6-af-8f-e5-b0-8f-e6-97-b6-e6-af-8f-e5-a4-a9-e7-ad-89-e7-b2-92-e5-ba-a6-e4-b8-8a" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/07/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s104-ef-bc-9a-e5-88-86-e6-9e-90-e7-94-a8-e6-88-b7-e5-8f-91-e8-a8-80-e5-9c-a8-e6-af-8f-e5-b0-8f-e6-97-b6-e6-af-8f-e5-a4-a9-e7-ad-89-e7-b2-92-e5-ba-a6-e4-b8-8a/" class="article-date">
  	<time datetime="2015-04-07T02:18:59.000Z" itemprop="datePublished">2015-04-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/07/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s104-ef-bc-9a-e5-88-86-e6-9e-90-e7-94-a8-e6-88-b7-e5-8f-91-e8-a8-80-e5-9c-a8-e6-af-8f-e5-b0-8f-e6-97-b6-e6-af-8f-e5-a4-a9-e7-ad-89-e7-b2-92-e5-ba-a6-e4-b8-8a/">数据分析S104：分析用户发言在每小时每天等粒度上的分布</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[python]<br>def s104(usrid=None, name=None):<br>    if not usrid:<br>        usrid=common.get_id(name)<br>    conn = sqlite3.connect(r’resource/chat.db’)<br>    df =pd.read_sql(‘SELECT * FROM chatdb WHERE usrid =?’,conn,params=(usrid,),parse_dates=[‘date’],index_col=[‘date’])</p>
<pre><code># print(df[[&apos;usrid&apos;,&apos;name&apos;],[&apos;name&apos;]].groupby(df.usrid).count().head(5))
df.insert(0,&apos;count&apos;,df[&apos;id&apos;])
df.groupby(lambda x:x.dayofweek).count()[[&apos;count&apos;]].plot(kind=&apos;bar&apos;)
df[[&apos;count&apos;]].resample(&amp;quot;M&amp;quot;, how=&amp;quot;count&amp;quot;).plot();
df2 =pd.read_sql(&apos;SELECT * FROM chatdb WHERE usrid =?&apos;,conn,params=(usrid,),parse_dates=[&apos;time&apos;],index_col=[&apos;time&apos;])
print(df2)
df2.insert(0,&apos;count&apos;,df2[&apos;id&apos;])
df2.groupby(lambda x:x.hour).count()[[&apos;count&apos;]].plot(kind=&apos;bar&apos;)
# df[&apos;count&apos;].resample(&amp;quot;M&amp;quot;, how=&amp;quot;count&amp;quot;).plot(lw=2);
# df[[&apos;count&apos;]].groupby(df.date).count().plot(kind=&apos;bar&apos;)
plt.show()
</code></pre><p>[/python]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据分析/">数据分析</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e4-bb-bb-e6-84-8f-e6-8c-89-e9-94-ae-e5-ae-9e-e7-8e-b0tab-e5-92-8cshifttab-e9-81-8d-e5-8e-86html-e5-85-83-e7-b4-a0-e7-9a-84-e5-8a-9f-e8-83-bd" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/01/e4-bb-bb-e6-84-8f-e6-8c-89-e9-94-ae-e5-ae-9e-e7-8e-b0tab-e5-92-8cshifttab-e9-81-8d-e5-8e-86html-e5-85-83-e7-b4-a0-e7-9a-84-e5-8a-9f-e8-83-bd/" class="article-date">
  	<time datetime="2015-04-01T07:49:49.000Z" itemprop="datePublished">2015-04-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/01/e4-bb-bb-e6-84-8f-e6-8c-89-e9-94-ae-e5-ae-9e-e7-8e-b0tab-e5-92-8cshifttab-e9-81-8d-e5-8e-86html-e5-85-83-e7-b4-a0-e7-9a-84-e5-8a-9f-e8-83-bd/">任意按键实现tab和shift+tab遍历html元素的功能</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h5><p>首先遍历所有有tabindex的标签，普通标签直接将tabindex的值存入data-tabindex中。对于第三方库渲染的特殊控件，默认的tabindex是无效的，在default.init中可以配置针对的初始化方法，将tabindex值绑定到真正的标签的data-tabindex属性上。<br>预处理完毕后，选择所有含data-tabindex属性的标签并排序后放入tabList中。此后当事件被触发时，事件函数会利用闭包特性取得tabList。<br>最后完成事件绑定，绑定前先解绑一次，以防止重复绑定。<br>&nbsp;</p>
<h5 id="事件响应："><a href="#事件响应：" class="headerlink" title="事件响应："></a>事件响应：</h5><p>触发事件后依次通过判断keyCode是否在forwardKey和backwardKey中来决定是否需要后移或前移。如果需要执行时对于普通标签执行默认的方法，对于包含defaulte.execute中的class的特殊标签则先执行标签中的处理函数，当处理函数返回true时会继续执行默认方法，否则阻止默认方法。</p>
<h5 id="调用方式："><a href="#调用方式：" class="headerlink" title="调用方式："></a>调用方式：</h5><p>在html中设置tabindex或通过js动态设置tabindex后，执行$.extendTab()即可。<br>$.extendTab.default定义了特殊控件处理方式及需要响应的按键，可以通过$.extend修改<br>[javascript]<br>(function ($) {<br>    $.extendTab = function (i18nData) {<br>        $(‘[tabindex]’).each(function (i, v) {<br>            var _this = $(v);<br>            var flag = true;<br>            $.each($.extendTab.default.init, function (key, value) {<br>                if (_this.hasClass(key)) {<br>                    value(_this);<br>                    flag = false;<br>                    return false;<br>                }<br>            });<br>            if (flag) {<br>                _this.attr(‘data-tabindex’, _this.attr(‘tabindex’));<br>            }<br>        });<br>        var tabList = $(‘[data-tabindex]’).sort(function (a, b) {<br>            return $(a).data(‘tabindex’) &gt; $(b).data(‘tabindex’)<br>        });<br>        tabList.off(‘keydown.extendTab’);<br>        tabList.on(‘keydown.extendTab’, function (e) {<br>            var target = $(e.currentTarget);<br>            if ($.extendTab.default.forwardKey.contains(e.keyCode)) {<br>                var flag = true;<br>                $.each($.extendTab.default.execute, function (key, value) {<br>                    if (target.hasClass(key)) {<br>                        flag = value(target);<br>                        return false;<br>                    }<br>                });<br>                if (flag) {<br>                    var _idx = tabList.index(this) + 1;<br>                    tabList.eq(_idx &gt;= (tabList.length) ? 0 : _idx).focus();<br>                    e.preventDefault();<br>                }<br>            } else if ($.extendTab.default.backwardKey.contains(e.keyCode)) {<br>                var flag = true;<br>                $.each($.extendTab.default.execute, function (key, value) {<br>                    if (target.hasClass(key)) {<br>                        flag = value(target);<br>                        return false;<br>                    }<br>                });<br>                if (flag) {<br>                    tabList.eq(tabList.index(this) - 1).focus();<br>                    e.preventDefault();<br>                }<br>            }<br>        });<br>    };</p>
<pre><code>$.extendTab.default = {
    init       : {
        &apos;combo-f&apos;: function (jq) {
            jq.next().find(&apos;.combo-text&apos;).attr(&apos;data-tabindex&apos;, jq.attr(&apos;tabindex&apos;));
        }
    },
    execute    : {
        &apos;combo-text&apos;: function (jq) {
            clearTimeout(jq.parent().prev().data(&apos;combo&apos;).timer);
            return true;
        }
    },
    forwardKey : [39, 13],
    backwardKey: [37]
}
</code></pre><p>})(jQuery);<br>[/javascript]<br><a href="https://github.com/woodensail/extendTab" target="_blank" rel="external">https://github.com/woodensail/extendTab</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaScript/">javaScript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s103-ef-bc-9a-e4-bd-bf-e7-94-a8-e7-bb-93-e5-b7-b4-e5-88-86-e8-af-8d-e5-b7-a5-e5-85-b7-e6-8f-90-e5-8f-96-e5-85-b3-e9-94-ae-e8-af-8d" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/31/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s103-ef-bc-9a-e4-bd-bf-e7-94-a8-e7-bb-93-e5-b7-b4-e5-88-86-e8-af-8d-e5-b7-a5-e5-85-b7-e6-8f-90-e5-8f-96-e5-85-b3-e9-94-ae-e8-af-8d/" class="article-date">
  	<time datetime="2015-03-31T05:10:17.000Z" itemprop="datePublished">2015-03-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/31/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s103-ef-bc-9a-e4-bd-bf-e7-94-a8-e7-bb-93-e5-b7-b4-e5-88-86-e8-af-8d-e5-b7-a5-e5-85-b7-e6-8f-90-e5-8f-96-e5-85-b3-e9-94-ae-e8-af-8d/">数据分析S103：使用结巴分词工具提取关键词</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这一主要是使用<a href="https://github.com/fxsjy/jieba" title="结巴分词" target="_blank" rel="external"></a>进行分词，并提取关键词。</p>
<h5 id="根据词频分析："><a href="#根据词频分析：" class="headerlink" title="根据词频分析："></a>根据词频分析：</h5><p>这是利用结巴分词后，除去黑名单，统计得到出现最多的次，方法简单。但是没有利用到结巴提供的工具，因此效果较差<br>[python]<br>def pet_phrase(usrid=None, name=None):<br>    with open(r’resource/stopWordList.txt’,encoding=’utf-8’) as f:<br>        black_list=[i for i in f.read().split(‘\n’)]<br>    speak_list=dataio.someonechat(usrid,name)<br>    rate={}<br>    for sentence in speak_list:<br>        for word in posseg.cut(sentence[‘contents’]):<br>            s=word.word<br>            if rate.get(s):<br>                rate[s]+=1<br>            elif s not in black_list:<br>                rate[s]=1<br>    return sorted(rate.items(),key=lambda x:x[1],reverse=True)[:10]<br>[/python]<br>&nbsp;</p>
<h5 id="利用结巴分析模块："><a href="#利用结巴分析模块：" class="headerlink" title="利用结巴分析模块："></a>利用结巴分析模块：</h5><p>[python]<br>result = ‘\n’.join([i[0] for i in conn.execute(‘SELECT contents FROM chatdb’)])<br>print(jieba.analyse.extract_tags(result, 10))<br>print(jieba.analyse.textrank(result,10))<br>[/python]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据分析/">数据分析</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s01-ef-bc-9a-e4-bb-8emht-e6-96-87-e4-bb-b6-e4-b8-ad-e6-8f-90-e5-8f-96qq-e7-94-a8-e6-88-b7-e5-8f-91-e8-a8-80" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/20/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s01-ef-bc-9a-e4-bb-8emht-e6-96-87-e4-bb-b6-e4-b8-ad-e6-8f-90-e5-8f-96qq-e7-94-a8-e6-88-b7-e5-8f-91-e8-a8-80/" class="article-date">
  	<time datetime="2015-03-20T02:23:41.000Z" itemprop="datePublished">2015-03-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/20/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s01-ef-bc-9a-e4-bb-8emht-e6-96-87-e4-bb-b6-e4-b8-ad-e6-8f-90-e5-8f-96qq-e7-94-a8-e6-88-b7-e5-8f-91-e8-a8-80/">数据分析S101：从mht文件中提取qq用户发言</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>qq的聊天记录可以导出为mht文件。这次的目标就是从mht文件中提取用户的聊天记录并存入数据库之中,同时要完成根据指定用户名查出其所有发言内容的功能。</p>
<h3 id="功能一：解析数据"><a href="#功能一：解析数据" class="headerlink" title="功能一：解析数据"></a>功能一：解析数据</h3><h5 id="获取记录："><a href="#获取记录：" class="headerlink" title="获取记录："></a>获取记录：</h5><p>这里是用的是BeautifulSoup4来对文档进行处理，首先查找所有tr标签。</p>
<p>[python]<br>with open(chatdata) as f:<br>    soup = BeautifulSoup(f.read())<br>    script = soup.find_all(‘tr’)<br>[/python]</p>
<p>&nbsp;</p>
<h5 id="分析记录："><a href="#分析记录：" class="headerlink" title="分析记录："></a>分析记录：</h5><p>先清空原有表，然后将日期置为None，开始遍历script。先清空原有表，然后将日期置为None，开始遍历script。<br>tr标签的内容可能有三种。1：一条发言记录，也就是我们要找的内容。2：一条日期，表明了直到下一个日期为止的内容的发言日期。3：无关内容，比如网页标题等。</p>
<h6 id="获取日期："><a href="#获取日期：" class="headerlink" title="获取日期："></a>获取日期：</h6><p>对于一条记录如果i.td.div不存在，即tr标签下有td标签，td标签下没有div标签时。认为这是一条日期记录，取td下的文本内容，忽略前四个字符即可得到’yyyy-MM-dd’格式的日期。此处为了符合数据库格式，将’-‘替换为了’/‘。</p>
<h6 id="获取聊天信息："><a href="#获取聊天信息：" class="headerlink" title="获取聊天信息："></a>获取聊天信息：</h6><ol>
<li>如果i.td.div存在，则可能为发言记录或者无关内容。这里直接按照发言记录来处理，同时捕获异常，如果是无关内容则会报异常，直接进入下一条的处理流程。</li>
<li>对于发言记录，首先取得i.td.div.div.string即发言人的名字及账号。首先判断最后一位是否为右括号，如果是则为数字型账号，否则则为邮箱型账号。通过两个正则可分别取得两种情况下的用户名和用户账户。然后通过i.td.div.contents[1]取得用户发言的时间。此时加上之前缓存的date，已经有了用户名，账号，日期，时间，只缺内容了。</li>
<li>通过i.td.contents[1].strings可以取得用户发言的全部文字内容。然后join合并为字符串即可。这样做可以快捷的取得所有文字内容，包括超链接等，不会有所遗漏，缺点是忽略了图片表情以及换行符。</li>
</ol>
<p>[python]<br>conn.execute(‘DELETE FROM chatdb’)<br>date = None<br>for i in script:<br>    try:<br>        if not i.td.div:<br>            date = i.td.string[4:].replace(‘-‘, r’/‘)<br>        else:<br>            speaker = i.td.div.div.string<br>            if ‘)’ == speaker[-1]:<br>                speaker = re.findall(r’(.<em>?)((\d+))‘, speaker)<br>            else:<br>                speaker = re.findall(r’(.</em>?)&lt;(.*?)&amp;get;’, speaker)<br>            s_name = speaker[0][0]<br>            s_id = speaker[0][1]<br>            time = i.td.div.contents[1]</p>
<pre><code>        content = &apos;&apos;.join([ttt for ttt in i.td.contents[1].strings])
        conn.execute(&apos;INSERT INTO chatdb (name,usrid,date, time, contents) VALUES(?,?,?,?,?)&apos;,
                     (s_name, s_id, date, time, content))
except Exception as e:
    pass
</code></pre><p>[/python]</p>
<p>&nbsp;</p>
<h3 id="功能二：查询发言内容"><a href="#功能二：查询发言内容" class="headerlink" title="功能二：查询发言内容"></a>功能二：查询发言内容</h3><p>首先查出该用户名最晚的一条发言记录的id，然后根据id查询出所有发言记录。最后组装成数组返回。<br>[python]<br>def someonechat(name):<br>    conn = sqlite3.connect(db_filename)<br>    result = conn.execute(‘SELECT usrid FROM chatdb ORDER BY date DESC,time DESC LIMIT 1 ‘)<br>    usrid = result.fetchone()[0]<br>    result = conn.execute(‘SELECT id,name,date,time,contents FROM chatdb WHERE usrid=?’, (usrid,))<br>    chatlist = [{‘id’: i[2], ‘name’: i[1], ‘usrid’: usrid, ‘date’: i[2], ‘time’: i[3], ‘contents’: i[4]} for i in<br>                result.fetchall()]<br>    return chatlist<br>[/python]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/未分类/">未分类</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-easyui-validatebox-e7-9a-84-e7-ac-ac-e4-b8-89-e7-a7-8d-e6-8c-87-e5-ae-9avalidtype-e6-96-b9-e5-bc-8f-e6-97-a0-e6-95-88" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/11/easyui-validatebox-e7-9a-84-e7-ac-ac-e4-b8-89-e7-a7-8d-e6-8c-87-e5-ae-9avalidtype-e6-96-b9-e5-bc-8f-e6-97-a0-e6-95-88/" class="article-date">
  	<time datetime="2015-03-11T09:34:08.000Z" itemprop="datePublished">2015-03-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/11/easyui-validatebox-e7-9a-84-e7-ac-ac-e4-b8-89-e7-a7-8d-e6-8c-87-e5-ae-9avalidtype-e6-96-b9-e5-bc-8f-e6-97-a0-e6-95-88/">easyui较低版本中validType无法接收对象参数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>validatebox即验证框，easyui中所有带验证功能的输入控件都是由此控件派生而成的。验证规则是通过使用 required 和 validType 特性来定义的。其中前者值为true或false，表示是否允许空值。后者则指定一条或多条验证规则，并给出对应验证规则所需要的自定义参数。<br>validatebox共有三种方式指定validType，分别为字符串，字符串数组和object。官网的介绍和例子如下：</p>
<blockquote>
<p>Defines the field valid type, such as email, url, etc. Possible values are:</p>
<p>1) a valid type string, apply a single validate rule.</p>
<p>2) a valid type array, apply multiple validate rules. The multiple validate rules on a field are available since version 1.3.2.</p>
<p>3) a key/value pairs, the key is the validing type name, the value is an array consisting validating parameters.</p>
</blockquote>
<p>[html]<br>&lt;input class=&quot;easyui-validatebox&quot; data-options=&quot;required:true,validType:’url’&quot;&gt;<br>&lt;input class=&quot;easyui-validatebox&quot; data-options=&quot;<br>    required:true,<br>    validType:[‘email’,’length[0,20]’]<br>&quot;&gt;<br>&lt;input class=&quot;easyui-validatebox&quot; data-options=&quot;<br>    required:true,<br>    validType:{<br>        length:[10,30],<br>        remote:[‘<a href="http://.../action.do&#39;,&#39;paramName">http://.../action.do&#39;,&#39;paramName</a>‘]<br>    }<br>&quot;&gt;<br>[/html]</p>
<p>其中，第三种方式较前两种有极大的改进，前两种方式只能以字符串方式传递自定义参数，即<strong>[10,30]</strong>部分。而第三种方式可以在参数数组中传递任意对象，包括function对象。因而可以轻松地完成回调而不需要通过toSource或直接以字符串形式写function。同时，可以实现闭包的功能。相较前两种灵活性要高得多。<br>但是，第三种方式在1.3.5版本中是无效的。我测试了在js中指定validType以及在data-options中指定validType，结果都是无效。接下来查源代码，发现在源码中对validType类型进行判断，如果是string则按第一种处理，反之按第二种处理，根本没有第三种情况。</p>
<p>[javascript]<br>if (_19.validType) {<br>    if (typeof _19.validType == &quot;string&quot;) {<br>        if (!_1c(_19.validType)) {<br>            return false;<br>        }<br>    } else {<br>        for (var i = 0; i &lt; _19.validType.length; i++) {<br>            if (!_1c(_19.validType[i])) {<br>                return false;<br>            }<br>        }<br>    }<br>}<br>[/javascript]</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/未分类/">未分类</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/2015/03/11/easyui-validatebox-e7-9a-84-e7-ac-ac-e4-b8-89-e7-a7-8d-e6-8c-87-e5-ae-9avalidtype-e6-96-b9-e5-bc-8f-e6-97-a0-e6-95-88/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-8f-90-e5-8f-96-e5-b9-b6-e4-bf-ae-e6-94-b9class-e6-96-87-e4-bb-b6-e4-b8-ad-e7-9a-84-e5-ad-97-e7-ac-a6-e4-b8-b2-e5-b8-b8-e9-87-8f" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/07/e6-8f-90-e5-8f-96-e5-b9-b6-e4-bf-ae-e6-94-b9class-e6-96-87-e4-bb-b6-e4-b8-ad-e7-9a-84-e5-ad-97-e7-ac-a6-e4-b8-b2-e5-b8-b8-e9-87-8f/" class="article-date">
  	<time datetime="2015-02-07T07:37:51.000Z" itemprop="datePublished">2015-02-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/07/e6-8f-90-e5-8f-96-e5-b9-b6-e4-bf-ae-e6-94-b9class-e6-96-87-e4-bb-b6-e4-b8-ad-e7-9a-84-e5-ad-97-e7-ac-a6-e4-b8-b2-e5-b8-b8-e9-87-8f/">提取并修改class文件中的字符串常量</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这两天在网上看到某个汉化组在汉化jar包过程中遇到开发者加扰，将部分class采取超长命名以及相同名称不同大小写的方式，导致windows下无法解压缩且专用汉化工具无法支持的情况。</p>
<p>所以我就做了脚本，用于将指定jar包或zip文件里所有class文件中的字符串常量提取出来，以JSON格式存入txt文件中。修改该文件中字符串的值，然后在利用该脚本重新导入，即可完成对jar包中class文件字符串常量的修改。</p>
<p>&nbsp;</p>
<p>脚本通过zipfile库遍历jar包读取所有class文件并解析，class文件解析的原理在我之前转载的「Class文件内容及常量池」中。之后通过json库保存信息。</p>
<p>汉化完成后再将汉化信息以json格式读入，并根据文件名已经常量编号对原字符串常量进行替换。</p>
<p>&nbsp;</p>
<p>项目地址：<a href="https://github.com/woodensail/ExtractString" target="_blank" rel="external">https://github.com/woodensail/ExtractString</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/未分类/">未分类</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-76" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/07/76/" class="article-date">
  	<time datetime="2015-02-07T07:14:15.000Z" itemprop="datePublished">2015-02-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/07/76/">Class文件内容及常量池</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当JVM运行Java程序的时候，它会加载对应的class文件，并提取class文件中的信息存放在JVM开辟出来的<span style="color: #0000ff;">方法区</span> 内存中。那么这个class文件里面到底有些什么内容呢？</p>
<p>&nbsp;</p>
<p><strong><span style="color: #800080;">一、class文件内容概述</span> </strong></p>
<p>&nbsp;</p>
<p>class文件是由8bits的字节流组成，全部字节构成了15个有意义的项目。这些项目之间没有任何无意义的字节，因此class文件非常紧凑。占据多字节空间的项目按照高位在前的顺序存放。下面我们详细讨论这些项目：</p>
<p>&nbsp;</p>
<p><span style="color: #800080;"><strong>★ magic(魔数)</strong>   <span style="color: #000000;"> 每个class文件的前4个字节称为魔数，值为0xCAFEBABE。作用在于轻松的辨别class文件与非class文件。</span> </span></p>
<p>&nbsp;</p>
<p><span style="color: #800080;"><strong>★ minor_version、major_version(次、主版本号)  </strong> <span style="color: #000000;">各占2个字节。随着Java技术的发展，class文件的格式会发生变化。版本号的作用在于使得虚拟机能够认识当前加载class的文件格式。从而准确的提取class文件信息。</span> </span></p>
<p>&nbsp;</p>
<p><span style="color: #800080;"><strong>★ constant_pool_count </strong> <strong>、constance_pool（常量池）  </strong> <span style="color: #000000;">从这里开始的字节组成了<span style="color: #0000ff;"><span style="color: #000000;">常量池</span> <span style="color: #000000;">。</span> </span> 存储了诸如符号常量、final常量值、基本数据类型的字面值等内容。JVM会将每一个常量构成一个常量表，每个常量表都有自己的入口地址。而实际上在JVM会将这些常量表存储在方法区中一块连续的内存空间中，因此class文件会根据常量表在常量池中的位置对其进行索引。比如常量池中的第一个常量表的索引值就是1，第二个就是2。有的时候常量表A需要常量表B的内容，则在常量表A中会存储常量表B的索引值x。而constant_pool_count就记录了有多少个常量表，或则所有多少个索引值。实际上，常量池中没有索引值为0的常量表，但这缺失的索引值也被记录在</span> </span> <span style="color: #800080;"><span style="color: #000000;">constant_pool_count中，因此</span> </span> <span style="color: #800080;"><span style="color: #000000;">constant_pool_count等于常量表的数量加1。关于常量池的具体内容，我们会在下面详细讲述，并用一个例子来显示整个class文件的内容。</span> </span></p>
<p>&nbsp;</p>
<p><span style="color: #800080;"><strong>★ access_flags(访问标志)   </strong> <span style="color: #000000;">占用2个字节。用来表明该class文件中定义的是类还是接口，访问修饰符是public还是缺省。类或接口是否是抽象的。类是否是final的。</span> </span></p>
<p>&nbsp;</p>
<p><span style="color: #800080;"><strong>★ this_class</strong> </span>     占用2个字节。  它是一个对常量池的索引。指向的是常量池中存储类名符号引用的CONSTANT_Class_info常量表(见下面常量池具体结构)。比如this_class=0x0001。则表示指向常量池中的第一个常量表。通常这个表是指向当前class文件所定义的类名。</p>
<p>&nbsp;</p>
<p><span style="color: #800080;"><strong>★ super_class  占用2个字节<span style="color: #000000;">  </span> </strong> <span style="color: #000000;">与this_class类似，指向存放当前class文件所定义类的超类名字的索引的</span> </span> <span style="color: #000000;">CONSTANT_Class_info常量表。</span></p>
<p>&nbsp;</p>
<p><span style="color: #800080;"><strong>★ inteface_count、interfaces  </strong> <span style="color: #000000;">interface_count是class文件所定义的类直接实现的接口或父类实现的接口的数量。占2个字节。intefaces包含了对每个接口的</span> </span> <span style="color: #000000;">CONSTANT_Class_info常量表的索引。</span> <span style="color: #800080;"><br></span></p>
<p>&nbsp;</p>
<p><span style="color: #800080;"><strong>★fields_count、fields   </strong> <span style="color: #000000;">fields_count表明了类中字段的数量</span> </span> <span style="color: #000000;">。fields是不同长度的field_info表的序列。这些field_info表中并不包含超类或父接口继承而来的字段。field_info表展示了一个字段的信息，包括字段的名字，描述符和修饰符。如果该字段是final的，那么还会展示其常量值。注意，这些信息有些存放在field_info里面，有些则存放在field_info所指向的常量池中。下面我们阐述一下这个field_info表的格式：</span></p>
<p>access_flags(2byte 访问修饰符)</p>
<p>name_index(2byte 存储字段名的常量表在常量池中的索引)</p>
<p>description_index(2byte 存储字段的所属类型的常量表在常量池中的索引)</p>
<p>attribute_count(2byte 属性表的数量)</p>
<p>attribute (属性)</p>
<p>其中attribute是由多个attribute_info组成。而JVM规范定义了字段的三种属性：ConstanceValue、Deprecated和Synthetic。</p>
<p>&nbsp;</p>
<p><span style="color: #800080;"><strong>★method_count、<span style="color: #800080;">methods </span> </strong> <span style="color: #000000;">与字段类似，method_count表明类中方法的数量和每个方法的常量表的索引。methods表明了不同长度的method_info表的序列。该表格式如下：</span> </span></p>
<p>access_flags(2byte 访问修饰符)</p>
<p>name_index(2byte 存储方法名的常量表在常量池中的索引)</p>
<p>description_index(2byte 存储方法的返回类型和参数类型的常量表在常量池中的索引)</p>
<p>attribute_count(2byte 属性表的数量)</p>
<p>attribute (属性)</p>
<p>其中方法的属性JVM规定了四种：Code，Deprecated，Exceptions，Synthetic。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="color: #800080;">二、常量池的具体结构</span> </strong></p>
<p>在Java程序中，有很多的东西是永恒的，不会在运行过程中变化。比如一个类的名字，一个类字段的名字/所属类型，一个类方法的名字/返回类型/参数名与所属类型，一个常量，还有在程序中出现的大量的字面值。比如下面小段源码红色显示的东西。</p>
<p>public class <span style="color: #ff0000;">ClassTest</span> {</p>
<p>private <span style="color: #ff0000;">String</span> <span style="color: #ff0000;">itemS</span> =”<span style="color: #ff0000;">我们</span> “;</p>
<p>private final <span style="color: #ff0000;">int itemI</span> =<span style="color: #ff0000;">100</span> ;</p>
<p>public <span style="color: #ff0000;">void setItemS</span> (<span style="color: #ff0000;">String para</span> ){…}</p>
<p>}</p>
<p>而这些在JVM解释执行程序的时候是非常重要的。那么编译器将源程序编译成class文件后，会用一部分字节分类存储这些永恒不变的红色东西。而这些字节我们就成为常量池。事实上，只有JVM加载class后，在方法区中为它们开辟了空间才更像一个“池”。</p>
<p>&nbsp;</p>
<p>正如上面所示，一个程序中有很多永恒的红色东西。每一个都是常量池中的一个常量表(常量项)。而这些常量表之间又有不同，class文件共有11种常量表，如下所示：</p>
<p><table style="border: 0pt solid #2a27d8; height: 248px;" border="0" width="541"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">常量表类型</span></td></p>
<p><td><span style="color: #0000ff;">标志值(占1 byte)</span></td></p>
<p><td><span style="color: #0000ff;">描述</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_Utf8</span></td></p>
<p><td><span style="color: #0000ff;">1</span></td></p>
<p><td><span style="color: #0000ff;">UTF-8编码的Unicode字符串</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_Integer</span></td></p>
<p><td><span style="color: #0000ff;">3</span></td></p>
<p><td><span style="color: #0000ff;">int类型的字面值</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_Float</span></td></p>
<p><td><span style="color: #0000ff;">4</span></td></p>
<p><td><span style="color: #0000ff;">float类型的字面值</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_Long</span></td></p>
<p><td><span style="color: #0000ff;">5</span></td></p>
<p><td><span style="color: #0000ff;">long类型的字面值</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_Double</span></td></p>
<p><td><span style="color: #0000ff;">6</span></td></p>
<p><td><span style="color: #0000ff;">double类型的字面值</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_Class</span></td></p>
<p><td><span style="color: #0000ff;">7</span></td></p>
<p><td><span style="color: #0000ff;">对一个类或接口的符号引用</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_String</span></td></p>
<p><td><span style="color: #0000ff;">8</span></td></p>
<p><td><span style="color: #0000ff;">String类型字面值的引用</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_Fieldref</span></td></p>
<p><td><span style="color: #0000ff;">9</span></td></p>
<p><td><span style="color: #0000ff;">对一个字段的符号引用</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_Methodref</span></td></p>
<p><td><span style="color: #0000ff;">10</span></td></p>
<p><td><span style="color: #0000ff;">对一个类中方法的符号引用</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_InterfaceMethodref</span></td></p>
<p><td><span style="color: #0000ff;">11</span></td></p>
<p><td><span style="color: #0000ff;">对一个接口中方法的符号引用</span></td><br></p>
<p><tr></tr></p>
<p><td><span style="color: #0000ff;">CONSTANT_NameAndType</span></td></p>
<p><td><span style="color: #0000ff;">12</span></td></p>
<p><td><span style="color: #0000ff;">对一个字段或方法的部分符号引用</span></td><br><br><br><br><span style="color: #ff0000;">(1) </span> <span style="color: #ff0000;">CONSTANT_Utf8   用UTF-8编码方式来表示程序中所有的重要常量字符串。<span style="color: #000000;">这些字符串包括：</span> </span> ①类或接口的全限定名， ②超类的全限定名，③父接口的全限定名， ④类字段名和所属类型名，⑤类方法名和返回类型名、以及参数名和所属类型名。⑥字符串字面值</p>
<p>表格式：   tag(标志1：占1byte)       length(字符串所占字节的长度，占2byte)      bytes(字符串字节序列)</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">(2) </span> <span style="color: #ff0000;">CONSTANT_Integer、</span> <span style="color: #ff0000;">CONSTANT_Float、</span> <span style="color: #ff0000;">CONSTANT_Long、</span> <span style="color: #ff0000;">CONSTANT_Double  所有基本数据类型的字面值。<span style="color: #000000;">比如在程序中出现的1用CONSTANT_Integer表示。<span style="color: #000000;">3.1415926F用</span> </span> </span> <span style="color: #000000;">CONSTANT_Float表示。</span> <span style="color: #ff0000;"><br></span></p>
<p>表格式：   tag             bytes(基本数据类型所需使用的字节序列)</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">(3) </span> <span style="color: #ff0000;">CONSTANT_Class  使用符号引用来表示类或接口。<span style="color: #000000;">我们知道所有类名都以</span> </span> <span style="color: #000000;">CONSTANT_Utf8表的形式存储。但是我们并不知道</span> <span style="color: #000000;">CONSTANT_Utf8表中哪些字符串是类名，那些是方法名。因此我们必须用一个指向类名字符串的符号引用常量来表明。</span></p>
<p>表格式：   tag    name_index(给出表示类或接口名的CONSTANT_Utf8表的索引)</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">(4)</span> <span style="color: #ff0000;">CONSTANT_String  同</span> <span style="color: #ff0000;">CONSTANT_Class，指向包含字符串字面值的</span> <span style="color: #ff0000;">CONSTANT_Utf8表。</span></p>
<p>表格式：   tag    string_index(给出表示字符串字面值的CONSTANT_Utf8表的索引)</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">(5)</span> <span style="color: #ff0000;">CONSTANT_Fieldref</span> <span style="color: #ff0000;">、</span> <span style="color: #ff0000;">CONSTANT_Methodref、</span> <span style="color: #ff0000;">CONSTANT_InterfaceMethodref</span> <span style="color: #ff0000;">  </span> <span style="color: #ff0000;">  指向包含该字段或方法所属类名的</span> <span style="color: #ff0000;">CONSTANT_Utf8表，以及指向包含该字段或方法的名字和描述符的</span> <span style="color: #ff0000;">CONSTANT_NameAndType</span> <span style="color: #ff0000;">表</span></p>
<p>表格式：   tag   class _index(给出包含所属类名的CONSTANT_Utf8表的索引)  name_and_type_index(包含字段名或方法名以及描<span style="color: #000000;">述符的</span> <span style="color: #000000;">CONSTANT_NameAndType表</span> <span style="color: #000000;">的索引)</span></p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">(6)</span> <span style="color: #ff0000;">CONSTANT_NameAndType </span> <span style="color: #ff0000;">指向包含字段名或方法名以及描述符的</span> <span style="color: #ff0000;">CONSTANT_Utf8表。</span></p>
<p>表格式：   tag    name_index(给出表示字段名或方法名的CONSTANT_Utf8表的索引)  type_index(给出表示描述符的CONSTANT_Utf8表的索引)</p>
<p>&nbsp;</p>
<p>下面是我将一个源程序编译成class文件后，对文件中的每一个字节的分析，可以更好的理解class文件的内容以及常量池的组成。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="color: #800080;">三、TestClass.class 文件实例分析</span> </strong></p>
<p>[java]<br>//源代码<br>package hr.test;<br>//ClassTest类<br>public class ClassTest {<br>    private int itemI=0;  //itemI类字段<br>    private static String itemS=&quot;我们&quot;; //itemS类字段<br>    private final float PI=3.1415926F;  //PI类字段<br>    //构造器方法<br>    public ClassTest(){<br>    }<br>    //getItemI方法<br>    public int getItemI(){<br>        return this.itemI;<br>    }<br>    //getItemS方法<br>    public static String getItemS(){<br>        return itemS;<br>    }<br>    //main主方法<br>    public static void main(String[] args) {<br>        ClassTest ct=new ClassTest();<br>    }<br>}<br>[/java]</p>
<p><pre class="java" style="display: none;" title="Class文件内容及常量池">//源代码<br>package hr.test;<br>//ClassTest类<br>public class ClassTest {<br>    private int itemI=0;  //itemI类字段<br>    private static String itemS=”我们”; //itemS类字段<br>    private final float PI=3.1415926F;  //PI类字段<br>    //构造器方法<br>    public ClassTest(){<br>    }<br>    //getItemI方法<br>    public int getItemI(){<br>        return this.itemI;<br>    }<br>    //getItemS方法<br>    public static String getItemS(){<br>        return itemS;<br>    }<br>    //main主方法<br>    public static void main(String[] args) {<br>        ClassTest ct=new ClassTest();<br>    }<br>}<br></pre><br>&nbsp;</p>
<p><span style="color: #800080;">TestClass.class 字节码分析<span style="color: #000000;">(字节顺序从上到下，从左到右。每个字节用一个0-255的十进制整数表示)</span> </span></p>
<p>&nbsp;</p>
<p><span style="background-color: #fbe3fc;">     <strong>202 254 186 190</strong>   <span style="color: #000000;">– 魔数</span> <span style="color: #000000;">             </span>                                                                                      </span><br><span style="background-color: #fbe3fc;">     <strong>0 0</strong>     <span style="color: #0000ff;"><span style="color: #000000;">– 次版本号</span>  </span>                                                                                                              </span><br><span style="background-color: #fbe3fc;">     <strong>0 50</strong>   <span style="color: #0000ff;"><span style="color: #000000;">– 主版本号   </span>   </span>                                                                                                          </span></p>
<p><span style="background-color: #d6d6ff;">     <strong>0 43</strong>   <span style="color: #000000;">– 常量池中常量表的数量有42个，下面红色括号中的数据表明该常量表所在常量池中的索引，从索引1开始</span> </span></p>
<p><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(1) </span> <strong>7 0 2 </strong> </span> <span style="color: #000000;"><span style="background-color: #d6d6ff;">– 对类ClassTest的符号引用(7为标志  02指向了常量池的索引2的位置) </span> </span></p>
<p><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(2) <strong><span style="color: #000000;">1</span> </strong> </span> </span> <strong><span style="background-color: #d6d6ff;">0 17 104 114 47 116 101 115 116 47 67 108 97 115 115 84 101 115 116  </span> </strong> <span style="color: #000000;"><span style="background-color: #d6d6ff;">– 类全限定名hr\test\ClassTest</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(3) </span> </span> <span style="background-color: #d6d6ff;"><strong>7 0 4 </strong> <span style="color: #000000;">  </span> <span style="color: #000000;">– 对类Object的符号引用</span> </span></p>
<p><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(4) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 16 106 97 118 97 47 108 97 110 103 47 79 98 106 101 99 116</strong>   <span style="color: #000000;">– 超类全限定名 java/lang/Object   </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(5) </span> </span> <span style="background-color: #d6d6ff;"><strong>1</strong> <strong> 0 5 105 116 101 109 73 </strong>   <span style="color: #000000;">–  第1个类字段名 itemI   </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(6) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 1 73</strong>    <span style="color: #000000;">–  I  第1个类字段类型为整型</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(7) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 5 105 116 101 109 83 </strong>   <span style="color: #000000;">–  第2个类字段名 itemS</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(8) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 18 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 </strong>   <span style="color: #000000;">–  第2个类字段类型的全限定名 Ljava/lang/String</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(9) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 2 80 73</strong> <span style="color: #000000;">– 第3个类字段名PI</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(10) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 1 70 </strong> <span style="color: #000000;">– 第3个类字段类型为float</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(11) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 13 67 111 110 115 116 97 110 116 86 97 108 117 101 </strong>   <span style="color: #000000;">—  第3个类字段为常量ConstantValue</span> </span></p>
<p><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(12) </span> </span> <span style="background-color: #d6d6ff;"><strong>4 64 73 15 218</strong>   <span style="color: #000000;">– 第3个类字段float字面值,占4bytes(3.1415926)</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(13) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 8 60 99 108 105 110 105 116 62 </strong>   <span style="color: #000000;">– &lt;clinit&gt;  初始化方法名</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(14) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 3 40 41 86</strong>    <span style="color: #000000;"> – </span> <span style="color: #000000;">()V 方法的返回类型为void</span> </span></p>
<p><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(15) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 4 67 111 100 101  </strong> <span style="color: #000000;">   </span> <span style="color: #000000;">– Code</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(16) </span> </span> <span style="background-color: #d6d6ff;"><strong>8 0 17</strong> <span style="color: #000000;">– String字符串字面值（0 17表示索引1 7） </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(17) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 6 230 136 145 228 187 172</strong>  <span style="color: #000000;">  </span> <span style="color: #000000;">– “我们”</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(18) </span> </span> <span style="background-color: #d6d6ff;"><strong>9 0 1 0 19 </strong> <span style="color: #000000;"> – 指向</span> </span> <span style="color: #000000;"><span style="background-color: #d6d6ff;">第2个 </span> <span style="background-color: #d6d6ff;">字段的引用(0 1指向索引1，0 19指向索引19） </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(19) </span> </span> <span style="background-color: #d6d6ff;"><strong>12 0 7 0 8</strong> <span style="color: #000000;">   </span> <span style="color: #000000;">–指向</span> </span> <span style="color: #000000;"><span style="background-color: #d6d6ff;">第2个 </span> <span style="background-color: #d6d6ff;">字段的名字和描述符的索引， </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(20) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 15 76 105 110 101 78 117 109 98 101 114 84 97 98 108 101 </strong> <span style="color: #000000;">  </span> <span style="color: #000000;">– LineNumberTable</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(21) </span> </span> <span style="background-color: #d6d6ff;"><strong>0 18 76 111 99 97 108 86 97 114 105 97 98 108 101 84 97 98 108 101 </strong>   <span style="color: #0000ff;">-<span style="color: #000000;">- LocalVariableTable</span> </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(22) </span> </span> <span style="background-color: #d6d6ff;"><strong>1 0 6 60 105 110 105 116 62</strong>   <span style="color: #000000;">– &lt;init&gt;   表示初始化方法名 </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(23) </span> </span> <span style="background-color: #d6d6ff;"><strong>10 0 3 0 24</strong> <span style="color: #000000;"> –  指向父类Object的构造器方法，0 3表示父类名常量表的索引，0 24表示存放该方法名称和描述符的引用的常量表的索引 </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(24) </span> </span> <span style="background-color: #d6d6ff;"><strong>12 0 22 0 14 </strong> <span style="color: #000000;">–  指向方法名和描述符的常量表的索引。0 22是方法名的常量表索引，0 14是描述符的常量表索引</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(25) </span> </span> <strong><span style="background-color: #d6d6ff;">9 0 1 0 26    </span> </strong> <span style="color: #000000;"><span style="background-color: #d6d6ff;">– 指向第1个字段的引用， 0 1表示字段所属类型的索引，0 26表示字段名和描述符的索引 </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(26) </span> </span> <strong><span style="background-color: #d6d6ff;">12 0 5 0 6  <span style="color: #000000;">  </span> <span style="color: #000000;">–</span> </span> </strong> <span style="color: #000000;"><span style="background-color: #d6d6ff;"> 指向第1个字段的名字和描述符的索引 </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(27) </span> </span> <strong><span style="background-color: #d6d6ff;">9 0 1 0 28    </span> </strong> <span style="color: #000000;"><span style="background-color: #d6d6ff;">– 指向第3个字段的引用， 0 1表示字段所属类型的索引，0 28表示字段名和描述符的索引 </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(28) </span> </span> <strong><span style="background-color: #d6d6ff;">12 0 9 0 10  </span> </strong> <span style="color: #000000;"><span style="background-color: #d6d6ff;">– 指向第3个字段的名字和描述符的索引 </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(29)</span> <strong>1 0 4 116 104 105 115</strong>    <span style="color: #000000;">–  隐含参数符号this</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(30)</span> <strong>1 0 11 76 67 108 97 115 115 84 101 115 116 59</strong>    <span style="color: #000000;">–  LClassTest;</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(31)</span> <strong>1 0 8 103 101 116 73 116 101 109 73</strong>    <span style="color: #000000;">-</span> <span style="color: #000000;">- 方法名 getItemI</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(32)</span> <strong>1 0 3 40 41 73</strong>    <span style="color: #000000;">– </span> </span> <span style="color: #000000;"><span style="background-color: #d6d6ff;">()I  </span> </span> <span style="color: #000000;"><span style="background-color: #d6d6ff;">方法描述符:返回类型int </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(33)</span> <strong>1 0 8 103 101 116 73 116 101 109 83</strong> <span style="color: #000000;">   </span> <span style="color: #000000;">–  方法名 getItemS</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(34)</span> <strong>1 0 20 40 41 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 </strong>    <span style="color: #000000;">— 方法描述符()Ljava/lang/String;</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(35)</span> <strong>1 0 4 109 97 105 110 </strong>    <span style="color: #000000;">–  主方法名main</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(36)</span> <strong>1 0 22 40 91 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59 41 86</strong>    <span style="color: #000000;">—  ()Ljava/lang/String;)V  主方法中的参数的字符串数组类型名</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(37)</span> <strong> 10 0 1 0 24    </strong> <span style="color: #000000;">指向当前</span> </span> <span style="color: #0000ff;"><span style="color: #000000;"><span style="background-color: #d6d6ff;">ClassTest </span> </span> <span style="background-color: #d6d6ff;"><span style="color: #000000;">类的构造器方法，0 1表示存放当前类名的常量表的索引。0 24是存放方法名和描述符的符号引用的常量表索引。</span>   </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(38)</span> <strong>1 0 4 97 114 103 115 </strong> <span style="color: #000000;">– 参数args</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(39)</span> <strong>1 0 19 91 76 106 97 118 97 47 108 97 110 103 47 83 116 114 105 110 103 59</strong>   <span style="color: #000000;">– 字符串数组 [Ljava/lang/String; </span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(40)</span> <strong>1 0 2 99 116</strong>    <span style="color: #000000;">—  对象符号ct</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(41)</span> <strong>1 0 10 83 111 117 114 99 101 70 105 108 101 </strong> <span style="color: #000000;">  </span> <span style="color: #000000;">– SourceFile</span> </span><br><span style="background-color: #d6d6ff;"><span style="color: #ff0000;">(42)</span> <strong>1 0 14 67 108 97 115 115 84 101 115 116 46 106 97 118 97</strong>    <span style="color: #000000;">– ClassTest.java    </span> </span></p>
<p>&nbsp;</p>
<p><span style="background-color: #ffffd6; color: #000000;"><strong>       0 33</strong> —- access_flag 访问标志  public<br><strong>       </strong> <strong>0 1</strong>   —- this_class  指向当前类的符号引用在常量池中的索引<br><strong>       </strong> <strong>0 3 </strong> —- super_class</span><br><strong>       </strong> <strong>0 0 </strong> <span style="background-color: #ffffd6;">—- inteface_count接口的数量</span> </p>
<p><span style="background-color: #d6ead6; color: #000000;"><strong>       0 3</strong>   —  field_count字段的数量</span></p>
<p><span style="background-color: #d6ead6; color: #000000;">       // </span> <span style="background-color: #d6ead6; color: #000000;">字段 itemI</span> <span style="background-color: #d6ead6; color: #000000;"><br><strong>       0 2 </strong> —- private 修饰符<br><strong>       0 5 </strong> —- 字段名在常量池中的索引，字段itemI<br><strong>       0 6</strong>   —- 字段的描述符(所属类型)在常量池中的索引<br><strong>       0 0</strong>   —  字段的属性信息表(attribute_info)的数量<br></span> <span style="background-color: #d6ead6; color: #000000;">// </span> <span style="background-color: #d6ead6; color: #000000;">字段 itemS</span> <span style="background-color: #d6ead6; color: #000000;"><br><strong>       0 10</strong>   —-  private static 修饰符<br><strong>       0 7 </strong> —字段名在常量池中的索引，字段itemS<br><strong>       0 8 </strong> —字段的描述符(所属类型)在常量池中的索引<br><strong>       0 0 </strong> —  字段的属性信息表(attribute_info)的数量<br></span> <span style="background-color: #d6ead6; color: #000000;">// </span> <span style="background-color: #d6ead6; color: #000000;">字段 PI  </span> <span style="background-color: #d6ead6; color: #000000;"><br><strong>       0 18</strong>   – private final 修饰符<br><strong>       0 9</strong> —字段名在常量池中的索引，//字段PI<br><strong>       0 10</strong> —字段的描述符(所属类型)在常量池中的索引<br><strong>       0 1 </strong> — 字段的属性信息表(attribute_info)的数量<br><strong>       0 11</strong>   — 属性名在常量池中的索引。即ConstantValue<br><strong>       0 0 0 2</strong> — 属性所占的字节长度<br><strong>       0 12</strong>   — 属性值在常量池中的索引。即常量字面值</span> </p>
<p><strong>       0 5  – </strong> <span style="background-color: #ccd6e0;">Method_count方法的数量</span><br><strong>       </strong> <span style="background-color: #ccd6e0;">//类的静态数据初始化方法&lt;clinit&gt;</span><br><strong>       0 8 </strong> <span style="background-color: #ccd6e0;">—- static 修饰符(所有的初始化方法都是static的)</span><br><strong>       0 13 </strong> <span style="background-color: #ccd6e0;">— 在常量池中的索引。初始化方法名&lt;clinit&gt;，该方法直接由JVM在特定的时候调用，并非由字节码生成。</span><br><strong>       0 14 — </strong> <span style="background-color: #ccd6e0;">在常量池中的索引。返回类型为void。</span></p>
<p><strong>       0 1 — </strong> <span style="background-color: #ccd6e0;">属性数量</span><br><strong>       0 15 – </strong> <span style="background-color: #ccd6e0;">属性名</span> <span style="background-color: #ccd6e0;">在常量池中的索引。即code</span><br><strong>       0 0 0 42 </strong> <span style="background-color: #ccd6e0;">—  属性所占的字节长度2</span><br><strong>       0 1 0 0 0 0 0 6 18 16 179 0 18 177 0 0 0 2 0 20 0 0 0 10 0 2 0 0 0 5 0 5 0 2 0 21 0 0 0 2 0 0 </strong> <span style="background-color: #ccd6e0;">—该方法的字节码指令序列和其他信息</span><br><strong>       </strong> <span style="background-color: #ccd6e0;">//类的普通实例数据的初始化方法，针对类构造器生成的&lt;init&gt;方法。</span><br><strong>       0 1 — </strong> <span style="background-color: #ccd6e0;">public 修饰符</span><br><strong>       0 22 </strong> <span style="background-color: #ccd6e0;">— 构初始化方法名&lt;init&gt;</span><br><strong>       0 14 — </strong> <span style="background-color: #ccd6e0;">构造器的返回类型为void</span><br><strong>       0 1  — </strong> <span style="background-color: #ccd6e0;">属性数量</span><br><strong>       0 15 </strong> <span style="background-color: #ccd6e0;">—  属性名在常量池中的索引。即Code</span><br><strong>       0 0 0 70 –</strong> <span style="background-color: #ccd6e0;">属性所占的字节长度70</span><br><strong>       0 2 0 1 0 0 0 16 42 183 0 23 42 3 181 0 25 42 18 12 181 0 27 177 0 0 0 2 0 200 0 0 18 0 4 0 0 0 </strong> <strong>8 0 4 0 4 0 9 0 6 0 15 0 9 0 21 0 0 0 12 0 10 0 0 16 0 29 0 30 0 0</strong> <span style="background-color: #ccd6e0;">—该方法的字节码指令序列和其他信息</span><br><strong>       </strong> <span style="background-color: #ccd6e0;">//getItemI方法</span><br><strong>       0 1 </strong> <span style="background-color: #ccd6e0;">— public 修饰符</span><br><strong>       0 31 </strong> <span style="background-color: #ccd6e0;">—  在常量池中的索引。方法名getItemI</span><br><strong>       0 32 </strong> <span style="background-color: #ccd6e0;">—  在常量池中的索引。方法返回类型为int</span><br><strong>       0 1 – </strong> <span style="background-color: #ccd6e0;">属性数量</span><br><strong>       0 15  </strong> <span style="background-color: #ccd6e0;">— 属性名在常量池中的索引。即Code</span><br><strong>       0 0 0 47 </strong> <span style="background-color: #ccd6e0;">—  属性所占的字节长度70</span><br><strong>       0 1 0 1 0 0 0 5 42 180 0 25 172 0 0 0 2 0 20 0 0 0 6 0 1 0 0 0 12 0 21 0 0 0 12 0 1 0 0 0 5 0 29 0 30 0 0  — </strong> <span style="background-color: #ccd6e0;">该方法的字节码指令序列和其他信息</span><br><strong>       </strong> <span style="background-color: #ccd6e0;">//getItemS方法</span><br><strong>       0 9 </strong> <span style="background-color: #ccd6e0;">— public static 修饰符</span><br><strong>       0 33 </strong> <span style="background-color: #ccd6e0;">—  在常量池中的索引。方法名getItemS</span><br><strong>       0 34 -</strong> <span style="background-color: #ccd6e0;">– 在常量池中的索引。方法返回类型为String</span><br><strong>       0 1 — </strong> <span style="background-color: #ccd6e0;">属性数量</span><br><strong>       0 15 – </strong> <span style="background-color: #ccd6e0;">属性名在常量池中的索引。即Code</span><br><strong>       0 0 0 36 </strong> <span style="background-color: #ccd6e0;">—  属性所占的字节长度36</span><br><strong>       0 1 0 0 0 0 0 4 178 0 18 176 0 0 0 2 0 20 0 0 0 6 0 1 0 0 0 16 0 21 0 0 0 2 0 0</strong> <span style="background-color: #ccd6e0;">–该方法的字节码指令序列和其他信息</span><br><strong>       </strong> <span style="background-color: #ccd6e0;">//main方法</span><br><strong>       0 9 </strong> <span style="background-color: #ccd6e0;">— public static 修饰符</span><br><strong>       0 35 </strong> <span style="background-color: #ccd6e0;">—  在常量池中的索引。主方法名main</span><br><strong>       0 36</strong> <span style="background-color: #ccd6e0;">– 在常量池中的索引。方法返回类型为String[]</span><br><strong>       0 1</strong> <span style="background-color: #ccd6e0;"> —  属性数量</span><br><strong>       0 15  </strong> <span style="background-color: #ccd6e0;">—  属性名在常量池中的索引。即Code</span><br><strong>       0 0 0  65 </strong> <span style="background-color: #ccd6e0;">—  属性所占的字节长度36</span><br><strong>       0 2 0 2 0 0 0 9 187 0 1 89 183 0 37 76 177 0 0 0 2 0 20 0 0 0 10 0 2 0 0 0 20 0 8 0 21 0 21 0 0 0 22 0 2 0 0 0 9 0 38 0 39 0 0 0 8 0 1 0 40 0 30 0 1 0 1 0 41 0 0 0 2 0 42 </strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>我们分析上面的字节码例子，不难看出：</p>
<p>&nbsp;</p>
<p>蓝色背景的常量池字节码区域：</p>
<p>(1) <span style="color: #ff0000;">所有的字面值都是存放在常量池中的。</span> 特别注意的是“我们”这个字符串常量也是在常量池中的。如果一个程序出现多个“我们”，那么常量池中也只会有一个。另外，也正是因为“我们”存放在常量池中，使得一些字符串的==比较变的需要琢磨了。</p>
<p>(2)<span style="color: #ff0000;">ClassTest并没有任何显示的父类。但在常量池中，我们发现有Object的符号常量存在。</span> 这也证实了在Java中，任何类都直接或间接继承了Object的，而Object并不需要在代码中显示继承，JVM会帮我们做到这一点。</p>
<p>(3)<span style="background-color: #ffffff; color: #ff0000;">常量池中有一个隐含参数this的符号常量。<span style="color: #000000;">即使程序中不存在this，JVM也会悄悄的设置一个这样的对象。</span> </span></p>
<p>&nbsp;</p>
<p>绿色背景的类字段字节码区域：</p>
<p>(1)字段PI是浮点型常量，<span style="color: #ff0000;">在编译期的字节码中就已经指定好了PI的字面值存储在常量池中的某个索引内</span> 。这一点也证实了Java中的常量在编译期就已经得到了值，在运行过程中是无法改变的。</p>
<p>&nbsp;</p>
<p>灰背景的类方法字节码区域：</p>
<p>(1)<span style="color: #ff0000;">主方法main是作为ClassTest的类方法存在的，在字节码中main和其他的类方法并没有什么区别。</span> 实际上，我们也确实可以通过ClassTest.main(..)来调用ClassTest中的main方法。</p>
<p>&nbsp;</p>
<p>(2)在class文件常量池字节码中有两个比较特别的方法名符号：&lt;clinit&gt;和&lt;init&gt;。其中&lt;clinit&gt;方法是编译器自己生成的，<span style="color: #ff0000;">编译器会把类静态变量的直接初始化语句和静态初始化语句块的代码都放到了class文件的&lt;clinit&gt;方法中。而对所有非静态非常量数据域的初始化工作要靠&lt;init&gt;方法来完成。<span style="color: #000000;">针对每一个类的构造方法，编译器都会产生一个&lt;init&gt;方法。即使是缺省构造器也不例外。</span></span></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Sail
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>