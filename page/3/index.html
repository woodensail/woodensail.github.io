<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Sail的日记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Sail的日记本">
<meta property="og:url" content="http://woodensail.github.io/page/3/index.html">
<meta property="og:site_name" content="Sail的日记本">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sail的日记本">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Sail的日记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Sail</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/woodensail" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JVM/" style="font-size: 12px;">JVM</a> <a href="/tags/JavaScript/" style="font-size: 12px;">JavaScript</a> <a href="/tags/PythonChallenge/" style="font-size: 10px;">PythonChallenge</a> <a href="/tags/bootstrap/" style="font-size: 12px;">bootstrap</a> <a href="/tags/ip/" style="font-size: 10px;">ip</a> <a href="/tags/j2ee/" style="font-size: 10px;">j2ee</a> <a href="/tags/jQuery/" style="font-size: 12px;">jQuery</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/javaScript/" style="font-size: 14px;">javaScript</a> <a href="/tags/keygen/" style="font-size: 10px;">keygen</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/rsa/" style="font-size: 10px;">rsa</a> <a href="/tags/加密/" style="font-size: 10px;">加密</a> <a href="/tags/数据分析/" style="font-size: 18px;">数据分析</a> <a href="/tags/每日一题/" style="font-size: 14px;">每日一题</a> <a href="/tags/游戏/" style="font-size: 12px;">游戏</a> <a href="/tags/练习/" style="font-size: 16px;">练习</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Sail</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Sail</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/woodensail" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-e6-a0-b9-e6-8d-aerequest-e8-8e-b7-e5-8f-96-e5-ae-a2-e6-88-b7-e7-ab-afip" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/02/05/e6-a0-b9-e6-8d-aerequest-e8-8e-b7-e5-8f-96-e5-ae-a2-e6-88-b7-e7-ab-afip/" class="article-date">
  	<time datetime="2015-02-05T08:50:47.000Z" itemprop="datePublished">2015-02-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/05/e6-a0-b9-e6-8d-aerequest-e8-8e-b7-e5-8f-96-e5-ae-a2-e6-88-b7-e7-ab-afip/">根据Request获取客户端IP</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在java里，获取客户端的IP地址的方法是：request.getRemoteAddr() ，这种方法在大部分情况下都是有效的。但是在通过了Apache,Squid等反向代理软件就不能获取到客户端的真实IP地址了。<br>如果使用了反向代理软件，将<a href="http://192.168.1.110:2046/" target="_blank" rel="external">http://192.168.1.110:2046/</a> 的URL反向代理为<a href="http://www.xxx.com/" target="_blank" rel="external">http://www.xxx.com/</a> 的URL时，用request.getRemoteAddr() 方法获取的IP地址是：127.0.0.1　或　192.168.1.110 ，而并不是客户端的真实ＩＰ。<br>经过代理以后，由于在客户端和服务之间增加了中间层，因此服务器无法直接拿到客户端的IP，服务器端应用也无法直接通过转发请求的地址返回给客户端。但是在转发请求的HTTP头信息中，增加了X－FORWARDED－FOR信息。用以跟踪原有的客户端IP地址和原来客户端请求的服务器地址。当我们访问<a href="http://www.xxx.com/index.jsp/" target="_blank" rel="external">http://www.xxx.com/index.jsp/</a> 时，其实并不是我们浏览器真正访问到了服务器上的index.jsp文件，而是先由代理服务器去访问<a href="http://192.168.1.110:2046/index.jsp" target="_blank" rel="external">http://192.168.1.110:2046/index.jsp</a> ，代理服务器再将访问到的结果返回给我们的浏览器，因为是代理服务器去访问index.jsp的，所以index.jsp中通过request.getRemoteAddr() 的方法获取的IP实际上是代理服务器的地址，并不是客户端的IP地址。<br>于是可得出获得客户端真实IP地址的方法一：</p>
<p>[java]<br>public String getRemortIP(HttpServletRequest request) {<br>  if (request.getHeader(&quot;x-forwarded-for&quot;) == null) {<br>   return request.getRemoteAddr();<br>  }<br>  return request.getHeader(&quot;x-forwarded-for&quot;);<br>}<br>[/java]</p>
<p>可是当我访问<a href="http://www.xxx.com/index.jsp/" target="_blank" rel="external">http://www.xxx.com/index.jsp/</a> 时，返回的IP地址始终是unknown，也并不是如上所示的127.0.0.1　或　192.168.1.110 了，而我访问<a href="http://192.168.1.110:2046/index.jsp" target="_blank" rel="external">http://192.168.1.110:2046/index.jsp</a> 时，则能返回客户端的真实IP地址，写了个方法去验证。原因出在了Squid上。squid.conf 的配制文件　forwarded_for 项默认是为on，如果 forwarded_for 设成了 off 　则：X-Forwarded-For: unknown<br>于是可得出获得客户端真实IP地址的方法二：</p>
<p>[java]<br>public String getRemoteHost(javax.servlet.http.HttpServletRequest request){<br>    String ip = request.getHeader(&quot;x-forwarded-for&quot;);<br>    if(ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)){<br>        ip = request.getHeader(&quot;Proxy-Client-IP&quot;);<br>    }<br>    if(ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)){<br>        ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);<br>    }<br>    if(ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)){<br>        ip = request.getRemoteAddr();<br>    }<br>    return ip.equals(&quot;0:0:0:0:0:0:0:1&quot;)?&quot;127.0.0.1&quot;:ip;<br>}<br>[/java]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ip/">ip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/j2ee/">j2ee</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Python3实现基于模板及逆向数据库的代码生成器" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/19/Python3实现基于模板及逆向数据库的代码生成器/" class="article-date">
  	<time datetime="2015-01-19T07:24:24.000Z" itemprop="datePublished">2015-01-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/19/Python3实现基于模板及逆向数据库的代码生成器/">Python3实现基于模板及逆向数据库的代码生成器</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这段时间由于有大量重复的代码工作，因此打算用代码生成器来提高工作效率。原理十分简单，根据数据库表名逆向工程得到表信息，利用得到的信息生成代码文件。<br>需要提的是一开始我才用的是字符串拼接和参数的方式来完成的，但是第一效率太低，而且几乎没有通用性，每个类型的文件都得写大量代码来进行字符串操作。后来改成了利用正则表达式对template文件进行操作，这样就可以把输出内容与代码隔离。当需要导入新模板时，只需要将一篇现成的代码保存为template文件然后用标签将其中的关键词替换就可以了。</p>
<p>主要代码分为两大块，一是核心的parser，利用正则表达式对标签进行解析；二是参数生成部分，主要是接受用户输入，然后逆向数据库得到字段信息，从用户输入和字段信息中提取关键信息，最后根据配置文件调用相应的模板文件和参数一起送入parser完成解析。因此如果想要增加参数，只需要在这部分添加代码即可。</p>
<p>目前为止，生成器提供一下几种标签：<br>1.<code>{name}</code>，简单替换。替换为name所对应的值。<br>2.{{?name:content?}}，可选内容。如果参数中的chosen数组不包含name则这段会被删除，否则将修饰用的标签删除保留content部分。<br>3.{{!name:content!}}，循环。这里的name应该是参数中所提供的dict list，parser将遍历lsit，同时用当前的dict中的参数对content进行置换，遍历完成后将所有content拼接在一起后置入文档中。另外，content内目前实现了<code>`{!a|b!}</code>的语法，当不是最后一次循环时会调用啊，否则调用b，后期打算更改为根据输入条件来选择输出内容。</p>
<p>具体代码就暂时不放了，现在的虽然能用，但是功能不够完善，2和3都需要改进，而且还有文档引用的功能没加，等全部完善了在放代码吧。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-easyui-window-e7-bb-84-e4-bb-b6-e4-b8-ad-e5-8c-85-e5-90-abiframe-e5-8f-af-e8-83-bd-e5-bc-95-e5-8f-91-e9-87-8d-e5-a4-8d-e8-af-b7-e6-b1-82-e5-92-8cjquery-e5-bc-82-e5-b8-b8" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/01/06/easyui-window-e7-bb-84-e4-bb-b6-e4-b8-ad-e5-8c-85-e5-90-abiframe-e5-8f-af-e8-83-bd-e5-bc-95-e5-8f-91-e9-87-8d-e5-a4-8d-e8-af-b7-e6-b1-82-e5-92-8cjquery-e5-bc-82-e5-b8-b8/" class="article-date">
  	<time datetime="2015-01-06T10:33:47.000Z" itemprop="datePublished">2015-01-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/06/easyui-window-e7-bb-84-e4-bb-b6-e4-b8-ad-e5-8c-85-e5-90-abiframe-e5-8f-af-e8-83-bd-e5-bc-95-e5-8f-91-e9-87-8d-e5-a4-8d-e8-af-b7-e6-b1-82-e5-92-8cjquery-e5-bc-82-e5-b8-b8/">EasyUI-window组件中包含iframe可能引发重复请求和jquery异常</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>准备工作：在A页面中引入jquery，下面放一个easyui的window，在window中包含一个iframe，src指向B页面。B页面只需要引入jquery即可。<br>[html]<br> &lt;div id=&quot;win&quot; class=&quot;easyui-window&quot;&gt;<br>    &lt;iframe src=’……’&gt;&lt;/iframe&gt;<br>&lt;/div&gt;<br>[/html]</p>
<p>我分别用Firefox Dev Edition 36.0a2,chrome 39.0.2171.95 m,IE 11.0.15进行了测试。其中ff和chrome正常，ie在jquery初始化过程中发生异常，无法完成初始化，子页面中无法调用jquery。<br>对dom树进行分析发现包含iframe标签的div已经被移动到新的位置上，因此怀疑easyui在初始化window的过程中对dom树的操作导致iframe初始化异常。于是查看网络请求，发现在ff中对B页面发起了两次请求，并且全部完成。chrome中对B页面发起了三次请求但其中两次被取消，ie中对B页面发起三次请求并且全部成功。可见easyui控件在初始化的过程中是会导致内部的iframe重复加载。<br>解决方案是将iframe中的src改为data-src，然后在easyui初始化完成后调用$(‘#frame’).attr(‘src’, $(‘#frame’).data(‘src’))来实现延迟加载即可避免子页面出错。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/未分类/">未分类</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonchallenge-e8-a7-a3-e9-a2-98-e8-ae-b0-e5-bd-950-17" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/24/pythonchallenge-e8-a7-a3-e9-a2-98-e8-ae-b0-e5-bd-950-17/" class="article-date">
  	<time datetime="2014-12-24T02:15:11.000Z" itemprop="datePublished">2014-12-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/24/pythonchallenge-e8-a7-a3-e9-a2-98-e8-ae-b0-e5-bd-950-17/">PythonChallenge解题记录(0-17)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>群里的每日一题计划似乎进行了没几次就被群主遗忘了，我在闲极无聊之下找到了PythonChallenge。pc的玩法基本上就是根据每一关的提示找出下一关的密码，和闯关游戏类似。不过pc的特点是解析下一关地址的过程极其复杂，无法人工完成，只能借助计算机编程实现。pc主要涉及了网络爬虫，图像处理和文件操作，虽说没有涉及python高级技巧，但是对于python的常用功能也算是基本都覆盖到了，因此非常适合新手在缺少练手机会是拿来熟练python。最后，我的解题过程基本上市先看网上的攻略找到题目中谜题的含义，然后自己编写代码来解题，我建议大家尽量也采用这种方法，可以减少在谜面上浪费的脑细胞。</p>
<p><strong>0</strong><br><a href="http://www.pythonchallenge.com/pc/def/0.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/0.html</a><br>根据提示2^38得到274877906944<br>[python]<br>2 ** 38<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/def/274877906944.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/274877906944.html</a></p>
<p><strong>1</strong><br><a href="http://www.pythonchallenge.com/pc/def/map.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/map.html</a><br>页面包含一段乱码：g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr’q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.<br>文字提示：everybody thinks twice before solving this.<br>图片提示：k-&gt;m,o-&gt;q,e-&gt;g<br>根据图片提示得出是凯撒密码，将字母后移两位得到”i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that’s why this text is so long. using string. maketrans() is recommended. now apply on the url.”<br>用同样的方式处理url”map”得到”ocr”<br>此处使用正则表达式匹配所有字母以避免影响到其他字符，匹配成功后使用lambda表达式完成字符替换<br>[python]<br> re.compile(‘[a-z]’).sub(lambda m: chr((ord(m.group(0)) - 97 + 2) % 26 + 97), hint)<br> re.compile(‘[a-z]’).sub(lambda m: chr((ord(m.group(0)) - 97 + 2) % 26 + 97), ‘map’)<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/def/ocr.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/ocr.html</a></p>
<p><strong>2</strong><br><a href="http://www.pythonchallenge.com/pc/def/ocr.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/ocr.html</a><br>根据提示在源代码中找到需要统计的字符串，统计完成后获得出现最少的次数min_times，筛选出所有出现次数为mint_times的字符拼接后得到equality<br>[python]<br>for i in level2_str:<br>    if None == count.get(i):<br>        count[i] = 1<br>        char.append(i)<br>    else:<br>        count[i] += 1<br>min_times = min(count.items(), key=lambda x: x[1])[1]<br>char = filter(lambda x: min_times == count[x], char)<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/def/equality.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/equality.html</a></p>
<p><strong>3</strong><br><a href="http://www.pythonchallenge.com/pc/def/equality.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/equality.html</a><br>老样子在源代码中找到字符串，然后正则匹配出左右刚好各有三个大写字母的小写字母，最后拼接得到linkedlist<br>[python]<br>re.compile(‘[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]’).findall(level3_str)<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/def/linkedlist.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/linkedlist.html</a></p>
<p><strong>4</strong><br><a href="http://www.pythonchallenge.com/pc/def/linkedlist.php" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/linkedlist.php</a><br>根据页面提示打开下一个页面，只不过这关页面太多，必须要借助爬虫才行。<br>需要注意的是这关有两处陷阱，第一处提示”Yes. Divide by two and keep going.”，需要将之前的数字直接除二得到下一个页面。第二处在中间有一个假数字，会导向一个错误页面。<br>[python]<br>pattern = ‘(?&lt;=[^0-9])\d+$’ pattern = ‘(?&lt;=[^0-9])\d+$’<br>while 1:<br>        page = request.urlopen(base + nothing).read().decode()<br>        match = re.search(pattern, page)<br>        if not match:<br>            if ‘Yes. Divide by two and keep going.’ == page:<br>                nothing = str(int(nothing) / 2)<br>            else:<br>                break<br>        else:<br>            nothing = match.group(0)<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/def/peak.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/peak.html</a></p>
<p><strong>5</strong><br><a href="http://www.pythonchallenge.com/pc/def/peak.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/peak.html</a><br>这一关涉及到利用pickle模块进行反序列化，爬取banner.p，然后反序列化可以得到类似[[(‘ ‘, 95)], [(‘ ‘, 14), (‘#’, 5), (‘ ‘, 70), (‘#’, 5), (‘ ‘, 1)]……]的数据，列表解析后输出可以得到用井号和空格拼成的channel单词<br>[python]<br>banner = pickle.load(request.urlopen(‘<a href="http://www.pythonchallenge.com/pc/def/banner.p" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/banner.p</a>‘))<br>return ‘’.join(‘’.join([pair[0] * pair[1] for pair in line]) + ‘\n’ for line in banner)<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/def/channel.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/channel.html</a></p>
<p><strong>6</strong><br><a href="http://www.pythonchallenge.com/pc/def/channel.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/channel.html</a><br>这关和第4关类似，也是循环读取，只不过这回变成了读取压缩文件。按第四关的方法读到最后提示需要压缩文件的注释，于是把所有注释拼接起来就可以得到类似上一关的字符画，内容为hockey。进入hockey.html后提示”it’s in the air. look at the letters. “，观察组成字符画所用的字母分别是o,x,y,g,e,n。于是输入oxygen.html，成功到达下一关。<br>[python]</p>
<h1 id="只展示与第4关不同的部分"><a href="#只展示与第4关不同的部分" class="headerlink" title="只展示与第4关不同的部分"></a>只展示与第4关不同的部分</h1><p>channel = zipfile.ZipFile(‘channel.zip’)<br>comments.append(channel.getinfo(nothing+’.txt’).comment.decode())<br>channel.read(nothing+’.txt’).decode()<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/def/oxygen.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/oxygen.html</a></p>
<p><strong>7</strong><br>这一关用到了图像处理，需要借助pillow库完成。<br>图片中央有一条灰阶，读取灰阶中每一格的RGB任一通道值，得到数字，转化为字符串后可以得到下一关的提示。再用正则将提示中的数字取出后再次转化就可以得到下一关的地址integrity。<br><a href="http://www.pythonchallenge.com/pc/def/oxygen.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/oxygen.html</a><br>[python]<br>img = Image.open(‘oxygen.png’)<br>hint = ‘’.join([chr(img.getpixel((i, 50))[0]) for i in range(0, 609, 7)])<br>return ‘’.join([chr(int(i)) for i in re.findall(‘\d+’, hint)])<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/def/integrity.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/integrity.html</a></p>
<p><strong>8</strong><br>这一关是用bz2解压缩，在源代码中有两个字符串，分别解压后得到’huge’和’file’，点击蜜蜂提示输入账号密码，将量单词分别输入跳转至下一个页面。<br><a href="http://www.pythonchallenge.com/pc/def/integrity.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/integrity.html</a><br>[python]<br>bz2.decompress(un).decode()<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/return/good.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/good.html</a></p>
<p><strong>9</strong><br>这题搞得跟脑筋急转弯似的，但仍然是图像处理。源代码中有两个数组first和second，分别将其中的数字两两一组做为坐标在图上画点。完成后可以得到两幅画，分别是牛的侧身和牛头，所以答案是bull。<br><a href="http://www.pythonchallenge.com/pc/return/good.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/good.html</a><br>[python]<br>im = Image.new(&quot;RGB&quot;, (500, 500))<br>    for i in range(0, len(level9_first), 2):<br>        im.putpixel((level9_first[i], level9_first[i + 1]), (255, 255, 255))<br>    im.save(‘level9_1.png’)<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/return/bull.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/bull.html</a></p>
<p><strong>10</strong><br>找规律的脑筋急转弯：<br>1 = 1个1 = 11<br>11 = 2个1 = 21<br>21 = 1个2加1个1 = 1211<br>依次类推。<br>我采用正则表达式的方式对数字进行分组，如将111221拆分为[111,22,1]。然后用列表解析的方式生成下一个数，[111,22,1]将被解析为[31,22,11],最后用join合并后进行下一轮处理。最后得到第31个数长度为5808<br><a href="http://www.pythonchallenge.com/pc/return/bull.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/bull.html</a><br>[python]<br>num = ‘1’<br>for i in range(0, 30):<br>num = ‘’.join([str(len(x[1]) + 1) + x[0] for x in re.findall(r’(\d)(\1*)’, num)])<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/return/5808.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/5808.html</a></p>
<p><strong>11</strong><br>还是图像处理，这次是将原图中所有xy坐标都为奇数和都为偶数的点取出生成单独的图片，生成完后可以明显的看到右上角有evil字样。<br><a href="http://www.pythonchallenge.com/pc/return/5808.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/5808.html</a><br>[python]<br>im = Image.open(‘cave.jpg’)<br>x, y = im.size<br>im_new = Image.new(im.mode, (int(x / 2), int(y / 2)))<br>for i in range(0, x, 2):<br>    for j in range(0, y, 2):<br>        im_new.putpixel((int(i / 2), int(j / 2)), im.getpixel((i, j)))<br>im_new.save(‘level11_1.jpg’)<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/return/evil.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/evil.html</a></p>
<p><strong>12</strong><br>又是一道脑筋急转弯的题。第一页中图名字是evil1.jpg，修改为evil2.jpg后看到提示将后缀名修改为gfx。修改完后成功下载evil2.gfx文件。另外根据evil1中分牌的提示可知需要将文件按分牌方式分成五份。我使用的方式是先将文件全部读出然后列表解析生成5个子bytes，最后写入新文件。写入完成后看图可知下一关地址为disproportional<br>lenge.com/pc/return/evil.html<br>[python]<br>source = bytearray(file.read())<br>s1 = bytes([source[i] for i in range(0, len(source), 5)])<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/return/disproportional.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/disproportional.html</a></p>
<p><strong>13</strong><br>页面提示”phone that evil”于是在图片中的电话上按键，按到e所在的5键时跳转到了phonebook.php，内容是一个报错的xml。查了一下这里是用到了xml远程调用，需要导入xmlrpc，用xmlrpc连接上phonebook.php后调用listMethods发现有一个phone方法。于是调用phone(‘evil’)，提示”He is not the evil”。再上网查了一下发现上一关中evil4.jpg有提示”Bert is evil”，于是phone(‘Bert’)，返回555-ITALY，下一关为italy<br><a href="http://www.pythonchallenge.com/pc/return/disproportional.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/disproportional.html</a><br>[python]<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/return/italy.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/italy.html</a></p>
<p><strong>14</strong><br>根据图片和源代码中的”100<em>100 = (100+99+99+98) + (…”提示，可知需要将下方10000</em>1的图从外向里盘绕形成一个100<em>100的新图片。按要求生成图片后结果是一只猫，进入cat.html提示”and its name is uzi. you’ll hear from him later.”。下一关地址为uzi<br><a href="http://www.pythonchallenge.com/pc/return/italy.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/italy.html</a><br>[python]<br>im = Image.open(‘pc/wire.png’)<br>im_new = Image.new(im.mode, (100, 100))<br>count = 0<br>for i in range(0, 50):<br>    jump = 99 - 2 </em> i<br>    for j in range(i, 99 - i):<br>        im_new.putpixel((j, i), im.getpixel((count, 0)))<br>        im_new.putpixel((99 - i, j), im.getpixel((count + jump, 0)))<br>        im_new.putpixel((99 - j, 99 - i), im.getpixel((count + 2 <em> jump, 0)))<br>        im_new.putpixel((i, 99 - j), im.getpixel((count + 3 </em> jump, 0)))<br>        count += 1<br>    count += jump * 3<br>im_new.save(&quot;pc/level14.jpg&quot;)<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/return/uzi.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/uzi.html</a></p>
<p><strong>15</strong><br>日历显示为1xx6年1月26日周一，且右下角显示二月有29天为闰年，找出所有符合该条件的日期，分别为1176，1356，1576，1756，1976年的1月26日。然后根据源文件中的提示”he ain’t the youngest, he is the second. buy flowers for tomorrow”。5个年份中第二靠后的是1756，搜索1756年1月27日为莫扎特的生日，符合所有提示。所以，下一关地址为mozart<br><a href="http://www.pythonchallenge.com/pc/return/uzi.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/uzi.html</a><br>[python]<br>for year in range(1016, 2000, 20):<br>    t = date(year, 1, 26)<br>    if (t+timedelta(34)).month == 2 and t.weekday() == 0:<br>        print(t.isoformat())<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/return/mozart.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/mozart.html</a></p>
<p><strong>16</strong><br>依旧是图像处理，干脆改名叫image challenge得了……这题是根据图片中的红色线段对齐每一行像素，对齐完后得到的图中有romance字样。<br><a href="http://www.pythonchallenge.com/pc/return/mozart.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/mozart.html</a><br>[python]<br>for i in range(0, 480):<br>    flag = 0<br>    for j in range(0, 640):<br>        if 195 == im.getpixel((j, i)):<br>            flag += 1<br>        if 5 == flag:<br>            flag = j<br>            break<br>    for j in range(0, 640):<br>        im_new.putpixel(((j - flag) % 640, i), im.getpixel((j, i)))<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/return/romance.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/romance.html</a></p>
<p><strong>17</strong><br>这一关算是一个总结，涉及了前面关卡中出图像处理外的大部分内容，同时加入了cookie的处理，而且猜谜性质更加突出了。为了完成这一关在网上差了不少的资料，总算是勉强完成了。<br>这一关的主图是一堆饼干，暗示的是cookie，而左下角的小图是第四关的图片，于是进入第四关,发现第四关的cookie中有提示：”info=you+should+have+followed+busynothing…”。尝试将用busynothing替换nothing，结果可行。接下来按照第四关的方式迭代，不过迭代的过程中需要收集cookie信息，每个网页都带有一字节的信息，将这些信息提取出来并且拼接得到一个bytes类型，开头是b’BZh91AY&amp;SY’,一看就是第8关的内容bz2，用bz2解压后得到’is it the 26th already? call his father and inform him that “the flowers are on their way”. he’ll understand.’。顺便一说，在’linkedlist.php?busynothing=19242’中cookie为’+’,但实际上应该是空格，我不清楚到底是官方出错还是有什么其他的我没发现的暗示，但是我在这上面几乎浪费了一上午的时间，最后选择了当busynothing为19242时手动替换结果，才算是成功解压出信息。<br>言归正传，上面的提示可以看出跟之前的莫扎特有关，上网查莫扎特的父亲名字是’Leopold Mozart’。接下来用第13关的方法phone(‘Leopold’),结果是’no! i mean yes! but ../stuff/violin.php.’，进入该页面后有一张莫扎特的照片，页面标题是’it’s me. what do you want?’，总算是找到莫扎特了……接下来通过cookie给莫扎特鲜花，也就是请求时在cookie中带上’the flowers are on their way’的信息，得到结果’oh well, don\’t you dare to forget the balloons.’其中balloons就是下一关的地址<br><a href="http://www.pythonchallenge.com/pc/return/romance.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/romance.html</a><br>[python]<br>page = ‘’<br>base = ‘<a href="http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=" target="_blank" rel="external">http://www.pythonchallenge.com/pc/def/linkedlist.php?busynothing=</a>‘<br>nothing = ‘12345’<br>pattern = ‘(?&lt;=[^0-9])\d+$’<br>cookies = []<br>while 1:<br>    while 1:<br>        try:<br>            page = request.urlopen(base + nothing, timeout=1)<br>            break<br>        except:<br>            pass<br>    data = page.read().decode()<br>    match = re.search(pattern, data)<br>    cookie = page.info().get(&quot;Set-Cookie&quot;)<br>    cookies.append(parse.unquote_to_bytes(re.search(&quot;(?&lt;==)[^;]+(?=;)&quot;, cookie).group(0)))<br>    if ‘19242’ == nothing:<br>        cookies.pop()<br>        cookies.append(b’ ‘)<br>    if not match:<br>        if ‘Yes. Divide by two and keep going.’ == page:<br>            nothing = str(int(nothing) / 2)<br>        else:<br>            break<br>    else:<br>        nothing = match.group(0)</p>
<p>data = bz2.decompress(b’’.join(cookies))<br>server = client.Server(&quot;<a href="http://www.pythonchallenge.com/pc/phonebook.php&amp;quot" target="_blank" rel="external">http://www.pythonchallenge.com/pc/phonebook.php&amp;quot</a>;)<br>server.phone(‘Leopold’)<br>http = urllib3.PoolManager().request(‘GET’, ‘<a href="http://www.pythonchallenge.com/pc/stuff/violin.php" target="_blank" rel="external">http://www.pythonchallenge.com/pc/stuff/violin.php</a>‘,<br>                                     headers={‘Cookie’: &quot;info=the flowers are on their way&quot;})<br>print(http.data)<br>[/python]<br>下一关地址：<a href="http://www.pythonchallenge.com/pc/return/balloons.html" target="_blank" rel="external">http://www.pythonchallenge.com/pc/return/balloons.html</a></p>
<p>PythonChallenge做到这里也算是告一段落了，后面还有十多关没做，不过接下来这段时间会很忙，所以只能找机会慢慢完成了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PythonChallenge/">PythonChallenge</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/练习/">练习</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e3-80-90-e6-88-91-e4-bb-ac-e4-b8-80-e8-b5-b7-e5-ad-a6python-e5-90-a7-e3-80-91-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98-e7-ac-ac4-e6-9c-9f" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/15/e3-80-90-e6-88-91-e4-bb-ac-e4-b8-80-e8-b5-b7-e5-ad-a6python-e5-90-a7-e3-80-91-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98-e7-ac-ac4-e6-9c-9f/" class="article-date">
  	<time datetime="2014-12-15T07:29:03.000Z" itemprop="datePublished">2014-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/15/e3-80-90-e6-88-91-e4-bb-ac-e4-b8-80-e8-b5-b7-e5-ad-a6python-e5-90-a7-e3-80-91-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98-e7-ac-ac4-e6-9c-9f/">Python每日一题 第4期</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.pythonla.com/read-25.html" title="题目：随机生成指定数量的随机字符串，并统计每个字符出现的次数。 " target="_blank" rel="external">题目：随机生成指定数量的随机字符串，并统计每个字符出现的次数。 </a></p>
<p>随机生成并统计字母数量最后拼接为字符串，原理很简单。此处为了提高效率采取一次生成多位的方式以减少随机次数，提高效率。需要注意的是15,16两行采用位运算以提高效率，如果改为求余和求模则效率会有答复下降。<br>另外，这里可以采用多线程机制以进一步提高速度。<br>[python]<br>import random</p>
<p>seed = ‘1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{}’<br>length = int(input(‘length:’))<br>count = [0] <em> 64<br>out_list = []<br>while length &gt; 0:<br>    if length &gt; 10000:<br>        c_length = 10000<br>    else:<br>        c_length = length<br>    length -= 10000<br>    ran_int = random.randint(1, 64 *</em> c_length)<br>    for i in range(0, c_length):<br>        t = ran_int &amp; 63<br>        ran_int &gt;&gt;= 6<br>        count[t] += 1<br>        out_list.append(seed[t])<br>print(count)<br>print(‘’.join(out_list))<br>[/python]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/每日一题/">每日一题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/练习/">练习</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98-e7-ac-ac3-e6-9c-9f" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/11/python-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98-e7-ac-ac3-e6-9c-9f/" class="article-date">
  	<time datetime="2014-12-11T14:28:06.000Z" itemprop="datePublished">2014-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/11/python-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98-e7-ac-ac3-e6-9c-9f/">Python每日一题 第3期</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.pythonla.com/read-20.html" title="题目：判断今天是2014年的第多少天？ " target="_blank" rel="external">题目：判断今天是2014年的第多少天？ </a></p>
<p>time.mktime(tuple) 可以将一个时间对象转化为浮点型表示的时间戳，需要传入一个时间对象「实质上是一个长度为9的元组」，其返回值为传入从1970年1月1日8时整到现在过去的秒数。<br>另外，struct_time对象共9个元素元素，分别为，年，月，日，时，分，秒，星期几，今年的第几天，是否夏令时。因此也可以这样调用mktime：<br>[python]<br>time.mktime((2014, 12, 11 ,21 ,50 ,30, 0, 0, 0))<br>[/python]</p>
<p>下面第一种是我一开始的写法，其基本思路是用当前时间的时间戳减去2014年1月1日0点整的时间戳得到今年过去的秒数。再除以86400后取整加1就可以得到当前是第几天。<br>后两种写法是在研究struct_time对象时发现的，可以直接获取struct_time格式的gmt时间和本地时间，其中第8项就是当前是本年的第几天。<br>[python]<br>import time<br>print(int((time.time() - time.mktime(time.strptime(‘2014’, ‘%Y’))) / (60 <em> 60 </em> 24)) + 1)<br>print(time.localtime()[7])<br>print(time.gmtime()[7])<br>[/python]</p>
<p>有关python中time和datatime的更多用法可参见help(time)及help(datatime)</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/每日一题/">每日一题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/练习/">练习</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98-e7-ac-ac2-e6-9c-9f" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/11/python-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98-e7-ac-ac2-e6-9c-9f/" class="article-date">
  	<time datetime="2014-12-11T04:25:45.000Z" itemprop="datePublished">2014-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/11/python-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98-e7-ac-ac2-e6-9c-9f/">Python每日一题 第2期</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://www.pythonla.com/read-17.html" title="【我们一起学Python吧】每日一题 第2期" target="_blank" rel="external">【我们一起学Python吧】每日一题 第2期</a><br>题目：企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？ </p>
<p>[python]<br>ratios = ((0, 0.1), (10, 0.075), (20, 0.05), (40, 0.03), (60, 0.015), (100, 0.01))<br>while 1:<br>    i_str = input(‘input a number:’)<br>    if ‘’ == i_str:<br>        exit(0)<br>    i = int(i_str)<br>    bonus = 0<br>    last = 0<br>    for ratio in ratios:<br>        if ratio[0] &lt; i:<br>            bonus += (i - ratio[0]) * (ratio[1] - last)<br>            last = ratio[1]<br>    print(round(bonus, 2))<br>[/python]</p>
<p>群里的解法，利用字典实现了switch，虽然有滥用eval的嫌疑，但是实现方式还是值得借鉴的<br>[python]<br>a = int(input(‘input a number:’))<br>item = {‘a&lt;=10’: ‘a<em>(1+0.1)’, ‘a&gt;10 and a&lt;=20’: ‘10</em>(1+0.1)+(a-10)<em>(1+0.075)’, ‘a&gt;20 and a&lt;40’: ‘(a-20)</em>(1+0.05)’,’40&lt;a&lt;=60’: ‘(a-40)<em>(1+0.03)’, ‘60&lt;a&lt;=100’: ‘(a-60)</em>(1+0.15)’, ‘a&gt;100’: ‘(a-100)*(1+0.01)’}<br>for i in item.keys():<br>    if eval(i):<br>        print(eval(item[i]))<br>[/python]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/每日一题/">每日一题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/练习/">练习</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/11/python-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98/" class="article-date">
  	<time datetime="2014-12-11T04:20:12.000Z" itemprop="datePublished">2014-12-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/11/python-e6-af-8f-e6-97-a5-e4-b8-80-e9-a2-98/">Python每日一题 第1期</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这两天参加的一个群里开展了每日一题的活动，虽然题目简单了点，但是拿来练练手也挺不错的。</p>
<p><a href="http://www.pythonla.com/read-13.html" title="【我们一起学Python吧】每日一题 第1期" target="_blank" rel="external">【我们一起学Python吧】每日一题 第1期</a><br>题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？<a href="http://www.pythonla.com/read-13.html" title="【我们一起学Python吧】每日一题 第1期" target="_blank" rel="external"></a><br>[python]<br>count = 0<br>for i in range(1, 4 ** 3):<br>    a = i % 4<br>    b = int(i / 4) % 4<br>    c = int(i / 16)<br>    if (a != b) &amp; (a != c) &amp; (b != c):<br>        count += 1<br>        print(str(c + 1) + str(b + 1) + str(a + 1))<br>print(‘total:%d’ % count)<br>[/python]</p>
<p>这是群中高手的解法，用到了列表解析。<br>[python]<br>lis = {1, 2, 3, 4}<br>l = [x <em> 100 + y </em> 10 + z for x in lis for y in lis - {x} for z in lis - {x} - {y}]<br>print(len(l), l)<br>[/python]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/每日一题/">每日一题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/练习/">练习</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python3-e5-ad-a6-e4-b9-a0-e6-b3-a8-e5-86-8c-e6-9c-ba-e7-9a-84-e5-ae-9e-e7-8e-b0" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/10/python3-e5-ad-a6-e4-b9-a0-e6-b3-a8-e5-86-8c-e6-9c-ba-e7-9a-84-e5-ae-9e-e7-8e-b0/" class="article-date">
  	<time datetime="2014-12-10T06:04:21.000Z" itemprop="datePublished">2014-12-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/10/python3-e5-ad-a6-e4-b9-a0-e6-b3-a8-e5-86-8c-e6-9c-ba-e7-9a-84-e5-ae-9e-e7-8e-b0/">python3学习——注册机的实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个注册机本来是用java写的的，但是在完成后收到了新的需求————添加gui。作为一个被java gui坑过一次的人，我绝不愿意再被坑第二次，而我手头又没装vs，所以便选择据说开发效率极高的python。<br>一边学一边做，开发过程虽说磕磕碰碰但是最后也算是顺利完成了，贴到网上，既是分享也是备忘。</p>
<p>整个项目主要用到了tkinter,pyDes,rsa,multiprocessing等库。tkinter用于实现gui。pyDes用于对key文件加密。multiprocessing用于实现多线程素性测试以提高rsaKey的生成效率。而最关键的则是rsa库了，但是事实上最后的版本中是没有引入rsa库的，原因是rsa库在打包过程中出现了问题，所以我参考rsa库和网上的一篇论文实现了一个简单myrsa库。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>一个相当简陋的对话框带着四个同样简陋的按钮。<br>生成授权：接受用户输入的授权信息包括机器码，授权开始结束日期等<br>选择密钥：选择授权时所使用的key<br>创建密钥：随机生成rsaKey<br>导出公钥：导出rsa算法中的e和n，这两个参数需要写死在被保护的程序的验证模块中<br>[python]<br>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    root = Tk()<br>    Button(root, text=’生成授权’, relief=RAISED, command=register).pack()<br>    Button(root, text=’选择密钥’, relief=RAISED, command=select_key).pack()<br>    Button(root, text=’创建密钥’, relief=RAISED, command=create_key).pack()<br>    Button(root, text=’导出公钥’, relief=RAISED, command=get_pubkey).pack()<br>    root.mainloop()<br>[/python]</p>
<h3 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h3><p>首先接受用户输入的密钥位数和密钥别名，然后调用myrsa库中的newkeys生成密钥，myrsa会根据当前机器的cpu核心数量开启相应数量的线程进行计算。「此处没有对length最大最小值进行约束，存在安全隐患」<br>密钥生成完毕后会调用save_key进行保存。程序将在key文件下下根据用户输入的别名生成一个文件夹，然后用文件头部的_des_key对密钥对加密，最后保存为pub.key和pri.key。加入des算法是因为注册机与key文件分离，为了防止key文件流出导致第三方任意授权所以对key进行加密。加入des后必须有key文件保存时所用的_des_key否则无法读取key文件。<br>此外，程序还会向同目录下生成一个xml文件保存key的别名、位数和kid，其中kid可写入被保护程序，用于判断授权文件所使用的key。<br>[python]<br>def create_key():<br>    length = simpledialog.askinteger(root, &quot;请输入密钥长度&quot;)<br>    remark = simpledialog.askstring(root, &quot;输入密钥名称&quot;)<br>    (pubkey, prikey) = newkeys(length)<br>    config = configparser.ConfigParser()<br>    config.add_section(‘info’)<br>    config.set(‘info’, ‘length’, str(length))<br>    save_key(pubkey, prikey, config, remark)<br>    messagebox.showinfo(&quot;&quot;, &quot;密钥生成完毕&quot;)</p>
<p>def save_key(pubkey, prikey, config, remark):<br>    pub = pubkey.save_pkcs1()<br>    pri = prikey.save_pkcs1()<br>    encrypter = des(&quot;DESCRYPT&quot;, CBC, _des_key, pad=None, padmode=PAD_PKCS5)</p>
<pre><code>time_stamp = int(time.time() * 1000)
if os.path.exists(&apos;key/&apos; + remark):
    i = 1
    while os.path.exists(&apos;key/&apos; + remark + &apos;_&apos; + str(i)):
        i += 1
    remark = remark + &apos;_&apos; + str(i)
config.set(&apos;info&apos;, &apos;kid&apos;, str(time_stamp))
e_pub = encrypter.encrypt(pub)
e_pri = encrypter.encrypt(pri)

file_prefix = &apos;key/&apos; + remark
os.makedirs(file_prefix)
with open(file_prefix + &apos;/info.ini&apos;, &apos;w&apos;) as f:
    config.write(f)
with open(file_prefix + &apos;/pub.key&apos;, &apos;wb&apos;) as f:
    f.write(e_pub)
with open(file_prefix + &apos;/pri.key&apos;, &apos;wb&apos;) as f:
    f.write(e_pri)
</code></pre><p>[/python]</p>
<h3 id="选择密钥"><a href="#选择密钥" class="headerlink" title="选择密钥"></a>选择密钥</h3><p>之前的控制台版可以列出所有密钥进行选择，gui版本只做了根据用户输入寻找key文件夹然后写入配置文件。<br>[python]<br>def select_key():<br>    key_dir = filedialog.askdirectory()<br>    if None == key_dir:<br>        return<br>    config = configparser.ConfigParser()<br>    config.read(‘config.ini’)<br>    if not config.has_section(‘info’):<br>        config.add_section(‘info’)<br>    config.set(‘info’, ‘current_key’, key_dir)<br>    with open(‘config.ini’, ‘w’) as f:<br>        config.write(f)<br>[/python]</p>
<h3 id="导出公钥"><a href="#导出公钥" class="headerlink" title="导出公钥"></a>导出公钥</h3><p>这里和上面的选择密钥原本在控制台版中都属于密钥管理的功能，为了适应gui做了弱化，会读取当前选择的key然后将kid,n,e写入指定的配置文件。<br>[python]<br>def get_pubkey():<br>    key_dir = filedialog.askdirectory()<br>    (pubkey, prikey, config) = load_key(key_dir)<br>    name = filedialog.asksaveasfilename(defaultextension=’.ini’, initialfile=’pubkey’,<br>                                        initialdir=’’, filetypes=[(‘公钥’, ‘.ini’)])<br>    pubkey_cfg = configparser.ConfigParser()<br>    pubkey_cfg.add_section(‘pubkey’)<br>    pubkey_cfg.set(‘pubkey’, ‘kid’, config.get(‘info’, ‘kid’))<br>    pubkey_cfg.set(‘pubkey’, ‘n’, str(getattr(pubkey, ‘n’)))<br>    pubkey_cfg.set(‘pubkey’, ‘e’, str(getattr(pubkey, ‘e’)))<br>    with open(name, ‘w’) as f:<br>        pubkey_cfg.write(f)<br>[/python]</p>
<h3 id="生成授权"><a href="#生成授权" class="headerlink" title="生成授权"></a>生成授权</h3><p>首先会读取配置文件获得当前的key，然后接受用户输入的授权信息并拼接成json串，最后调用_encrypt加密。加密完后会进行解密与原信息比对如果无法通过校验会提示密钥可能失效。<br>最后新建一个二进制文件在前8位写入kid，然后写入加密后的授权信息<br>[python]<br>def register():<br>    if not os.path.exists(‘config.ini’):<br>        select_key()<br>        print(1)<br>    config = configparser.ConfigParser()<br>    config.read(‘config.ini’)<br>    try:<br>        current_key = config.get(‘info’, ‘current_key’)<br>        print(current_key)<br>        load_key(current_key)<br>        print(3)<br>    except Exception:<br>        select_key()<br>        current_key = config.get(‘info’, ‘current_key’)</p>
<pre><code>code = simpledialog.askstring(root, &apos;请输入机器码&apos;)
begin_str = simpledialog.askstring(root, &apos;请输入授权开始日期(yyyy-MM-dd)&apos;)
end_str = simpledialog.askstring(root, &apos;请输入授权结束日期(yyyy-MM-dd)&apos;)
count = simpledialog.askstring(root, &apos;请输入客户端数量&apos;)
name = filedialog.asksaveasfilename(defaultextension=&apos;.license&apos;, initialdir=&apos;&apos;, initialfile=str(int(time.time())),
                                    filetypes=[(&apos;授权文件&apos;, &apos;.license&apos;)])
reg_info = {}
if not None == code:
    reg_info[&apos;code&apos;] = code
if not None == begin_str:
    begin_date = time.strptime(begin_str, &amp;quot;%Y-%m-%d&amp;quot;)
    reg_info[&apos;beginDate&apos;] = int(time.mktime(begin_date) * 1000)
if not None == end_str:
    end_date = time.strptime(end_str, &amp;quot;%Y-%m-%d&amp;quot;)
    reg_info[&apos;endDate&apos;] = int(time.mktime(end_date) * 1000)
if not None == count:
    reg_info[&apos;count&apos;] = count
json = JSONEncoder().encode(reg_info)

(pubkey, prikey, config) = load_key(current_key)
e = getattr(prikey, &apos;e&apos;)
d = getattr(prikey, &apos;d&apos;)
setattr(prikey, &apos;e&apos;, d)
setattr(prikey, &apos;d&apos;, e)
setattr(pubkey, &apos;e&apos;, d)
e_json = _encrypt(json.encode(), pubkey)
d_json = _decrypt(e_json, prikey)

if not json.encode() == d_json:
    print(&amp;quot;校验失败，密钥可能损坏。请确认license是否有效&amp;quot;)

with open(name, &apos;wb&apos;) as f:
    f.write(struct.pack(&apos;&amp;gt;q&apos;, int(config.get(&apos;info&apos;, &apos;kid&apos;))))
    f.write(e_json)
</code></pre><p>[/python]</p>
<h3 id="验证部分"><a href="#验证部分" class="headerlink" title="验证部分"></a>验证部分</h3><p>关于被保护的程序中的验证部分这里以java举例，需要将导出公钥中得到的e,d,kid以常量形式写入程序，如果对不同版本需要隔离只需要修改常量即可。<br>在验证部分会读取指定文件，然后读取前八位与常量kid比较如果不同则认为授权与软件版本不匹配，如果相同则利用常量n和e生成公钥对剩余部分进行解密。解密后得到授权信息开始对机器码等参数进行验证并返回结果。<br>[java]<br>private static final String modulus = &quot;<strong><em>&quot;;<br>private static final String publicExponent = &quot;65537&quot;;<br>private static final long kid = </em></strong>L;</p>
<p>try (DataInputStream in = new DataInputStream(new BufferedInputStream(<br>    new FileInputStream(file)))) {</p>
<pre><code>Long licenseKid = in.readLong();
if (kid != licenseKid) {
    return false;
}
byte[] license = new byte[(int) file.length() - 8];
in.read(license);

RSAPublicKey pubKey = (RSAPublicKey) KeyFactory.getInstance(&amp;quot;RSA&amp;quot;)
    .generatePublic(
        new RSAPublicKeySpec(new BigInteger(modulus),
            new BigInteger(publicExponent)));

String licenseJsonString = RSAUtil.decryptByPublicKey(
    RSAUtil.bcd2Str(license), pubKey);
JSONObject jsonObject = (JSONObject) new JSONParser()
    .parse(licenseJsonString);

String code = (String) jsonObject.get(&amp;quot;code&amp;quot;);
if (null != code &amp;amp;&amp;amp; !getSigarSequence().equals(code)) {
    return false;
}
Long beginDate = (Long) jsonObject.get(&amp;quot;beginDate&amp;quot;);
if (null != beginDate &amp;amp;&amp;amp; beginDate &amp;gt; new Date().getTime()) {
    return false;
}
Long endDate = (Long) jsonObject.get(&amp;quot;endDate&amp;quot;);
if (null != endDate &amp;amp;&amp;amp; endDate &amp;lt; new Date().getTime()) {
    return false;
}
Object o = jsonObject.get(&amp;quot;count&amp;quot;);
Integer count = o instanceof String ? Integer.valueOf((String) o)
    : (Integer) o;
if (null != count) {
    //TODO 设置客户端数量
}
return true;
</code></pre><p>} catch (Exception e) {<br>    e.printStackTrace();<br>    return false;<br>}<br>[/java]</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说虽然在学习python方面花了不少时间，但是python的开发效率的确很高，对同类元素的高度整合使得python开发的过程中用于很少为了「哪一种方案更好」这种事而浪费时间。虽然执行效率偏低，但是这对于一些轻量级的工具应用而言，省下来的开发时间远比程序执行所花费的时间来的多，的确是开发各种小工具的首选。</p>
<p>另外，上面提到过rsa无法打包的问题，附件中已经用我自己实现的库代替了rsa，源代码下载后可以使用cxfreeze打包为exe文件。</p>
<p><a href="http://www.woodensail.tk/archives/26/reg" target="_blank" rel="external">python3实现注册机源码</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/keygen/">keygen</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rsa/">rsa</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/加密/">加密</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Sail
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>