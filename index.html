<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Sail的日记本</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Sail的日记本">
<meta property="og:url" content="http://woodensail.github.io/index.html">
<meta property="og:site_name" content="Sail的日记本">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sail的日记本">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Sail的日记本" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Sail</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/woodensail" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JVM/" style="font-size: 12px;">JVM</a> <a href="/tags/JavaScript/" style="font-size: 12px;">JavaScript</a> <a href="/tags/PythonChallenge/" style="font-size: 10px;">PythonChallenge</a> <a href="/tags/bootstrap/" style="font-size: 12px;">bootstrap</a> <a href="/tags/ip/" style="font-size: 10px;">ip</a> <a href="/tags/j2ee/" style="font-size: 10px;">j2ee</a> <a href="/tags/jQuery/" style="font-size: 12px;">jQuery</a> <a href="/tags/java/" style="font-size: 14px;">java</a> <a href="/tags/javaScript/" style="font-size: 14px;">javaScript</a> <a href="/tags/keygen/" style="font-size: 10px;">keygen</a> <a href="/tags/python/" style="font-size: 20px;">python</a> <a href="/tags/rsa/" style="font-size: 10px;">rsa</a> <a href="/tags/加密/" style="font-size: 10px;">加密</a> <a href="/tags/数据分析/" style="font-size: 18px;">数据分析</a> <a href="/tags/每日一题/" style="font-size: 14px;">每日一题</a> <a href="/tags/游戏/" style="font-size: 12px;">游戏</a> <a href="/tags/练习/" style="font-size: 16px;">练习</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Sail</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="null" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Sail</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/woodensail" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-游戏开发日记-战斗核心" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/游戏开发日记-战斗核心/" class="article-date">
  	<time datetime="2016-05-06T05:21:53.000Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/游戏开发日记-战斗核心/">游戏开发日记-战斗核心</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>正如探险日志名字所表达的那样，该游戏的核心模块是其日志生成系统。而日志生成系统则分为探索和战斗两大块。我的计划便是从战斗模块开始开发。这次开发的是战斗系统的核心，核心开发完后其余的法术系统、策略系统等会一个一个开发并挂载到核心之上。</p>
<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><p>在战斗核心部分，我并不打算模仿探险日志自身回合机制，而是打算模仿Tome4，采用行动点系统。系统会依次扫描每个生物，首先分配点数，然后由该生物进行行动并消耗点数，若有剩余可以继续行动，直到行动点为0或负数为止，然后开始调度下一个生物。另外，如果行动点负值太大，也可能直接跳过该轮。<br>这种机制的优点在于可以较为简单地实现一轮多动和多轮施法，并且相较传统即时制，对cpu的消耗极少。</p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>战斗核心主要包括入口函数battle Function，时间队列TimeQueue Class，生物Creature class以及其他辅助模块</p>
<h2 id="battle-Function"><a href="#battle-Function" class="headerlink" title="battle Function"></a>battle Function</h2><p>这个函数是战斗系统的入口函数，由于战斗系统最终会挂载在探索系统之下，所以该函数负责的是接受探索系统传来的初始信息，生成战斗报告并返回给上级。由于目前其他部分都还没有设计所以该函数目前只负责初始化一个时间队列，然后调用时间队列生成战斗数据，最后将结果返回。</p>
<h2 id="TimeQueue-Class"><a href="#TimeQueue-Class" class="headerlink" title="TimeQueue Class"></a>TimeQueue Class</h2><p>一开始我只是打算把TimeQueue做成一个类型行动序列的东西。但是后来发现把行动序列单独做成一个小模块就目前而言意义不大，因而最终就做成了一个行动调度器。<br>该队列的主要入口为run方法。run方法会首先检测是否有一方已经全部被击败，如果没有则判断当前生物是否有行动能力。如果有行动能力则会指令该生物进行行动，最后根据返回的结果生成动作记录并做死亡检测。否则将焦点移动到下一个生物并分配行动点。</p>
<h2 id="Creature-Class"><a href="#Creature-Class" class="headerlink" title="Creature Class"></a>Creature Class</h2><p>生物类代表的是战斗中的所有生物，核心方法为action。action主要是根据战斗局面做出决策选择行动，并将行动结果返回上级，然而决策系统还没开始做，所以目前action是直接调用attack进行攻击</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/游戏/">游戏</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/游戏/">游戏</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-游戏开发日记-引言" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/06/游戏开发日记-引言/" class="article-date">
  	<time datetime="2016-05-06T04:50:28.000Z" itemprop="datePublished">2016-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/06/游戏开发日记-引言/">游戏开发日记-引言</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一直以来我都希望能找一个开源的游戏项目参与进去。但是成熟的项目过于复杂，别说参与就连读懂都很难，而一些简洁的独立游戏有没有哪个愿意开源的，所以这个想法当现在位置仍然还只是愿望。</p>
<p>而这次打算开始动手的原因是最近玩儿的《探险日志2》。这是一个很赞的idel game，框架设计很不错，非常简洁却又极具改造的潜力。所以我打算干脆自己模仿《探险日志2》也来写一个游戏。</p>
<p>以下是项目地址：<a href="https://github.com/woodensail/project1" target="_blank" rel="external">https://github.com/woodensail/project1</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/游戏/">游戏</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/游戏/">游戏</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e8-a7-a3-e5-86-b3-e9-83-a8-e5-88-86jquery-e6-8f-92-e4-bb-b6-e6-b8-b2-e6-9f-93-e6-97-b6-e5-88-a0-e9-99-a4-e5-8e-9f-e6-a0-87-e7-ad-be-e5-b8-a6-e6-9d-a5-e7-9a-84-e4-ba-8b-e4-bb-b6-e5-a4-b1-e6-95-88" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/06/e8-a7-a3-e5-86-b3-e9-83-a8-e5-88-86jquery-e6-8f-92-e4-bb-b6-e6-b8-b2-e6-9f-93-e6-97-b6-e5-88-a0-e9-99-a4-e5-8e-9f-e6-a0-87-e7-ad-be-e5-b8-a6-e6-9d-a5-e7-9a-84-e4-ba-8b-e4-bb-b6-e5-a4-b1-e6-95-88/" class="article-date">
  	<time datetime="2015-05-06T13:47:28.000Z" itemprop="datePublished">2015-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/06/e8-a7-a3-e5-86-b3-e9-83-a8-e5-88-86jquery-e6-8f-92-e4-bb-b6-e6-b8-b2-e6-9f-93-e6-97-b6-e5-88-a0-e9-99-a4-e5-8e-9f-e6-a0-87-e7-ad-be-e5-b8-a6-e6-9d-a5-e7-9a-84-e4-ba-8b-e4-bb-b6-e5-a4-b1-e6-95-88/">解决部分jquery插件渲染时删除原标签带来的事件失效和jquery对象丢失</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>jQuery插件在渲染控件的过程中进程会需要用新的标签来代替初始标签，有写插件会将原标签隐藏同时将事件和函数都绑定在原标签上来保证渲染之前的jquery对象依然有效 ，并且绑定的事件不丢失。<br>但是，有些插件则会选择将原标标签删除后，把id等必要信息复制入新标签中，在这个过程中，所有指向原标签的jquery对象会全部失效，同时如果插件没有进行处理的话原标签的class和绑定的事件也会丢失。所以需要进行一定的处理。</p>
<p>处理分为两个函数，一个函数在渲染前提取数据，另一个在渲染后注入数据。调用方式如下：</p>
<p>[javascript]<br>var _data = getData(jq);<br>jq.<em>**</em> // 此处调用插件的渲染语句<br>setData(_data);<br>}<br>[/javascript]</p>
<p>getData返回一个obj包含了原始标签的包装对象，事件和class，如果有需要还可以继续添加。<br>setData第一句是用原始的选择器初始化一个jQuery对象获得新标签，然后用新jQuery对象中的dom替换老的，从而保证所有指向老jQuery对象的变量都会受到影响。注意，此处不能直接data.jq=$(data.jq.selector)，这样实际上是改变了data.jq的指向，原来的类数组并没有得到改变。<br>setData第二三句分别将之前提取出的事件和classes注入新标签中。<br>[javascript]<br>function getData(jq) {<br>    return {<br>        jq     : jq,<br>        events : $.<em>data(jq[0], ‘events’),<br>        classes: </em>.filter(jq.attr(‘class’).split(‘ ‘), function (v) {<br>            return _.startsWith(v,’dhc-‘);<br>        }).join(‘ ‘)<br>    };<br>}</p>
<p>function setData(data) {<br>    data.jq[0] = $(data.jq.selector)[0];<br>    $.extend($._data(data.jq[0], ‘events’), data.events);<br>    data.jq.addClass(data.classes);<br>}<br>[/javascript]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaScript/">javaScript</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/JavaScript/">JavaScript</a><a class="article-category-link" href="/categories/JavaScript/前端/">前端</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-jvm-e7-9a-84-e7-bc-96-e8-af-91-e6-97-b6-e5-a4-9a-e6-80-81-e4-b8-8e-e7-b1-bb-e5-9e-8b-e6-93-a6-e9-99-a4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/05/04/jvm-e7-9a-84-e7-bc-96-e8-af-91-e6-97-b6-e5-a4-9a-e6-80-81-e4-b8-8e-e7-b1-bb-e5-9e-8b-e6-93-a6-e9-99-a4/" class="article-date">
  	<time datetime="2015-05-04T08:07:35.000Z" itemprop="datePublished">2015-05-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/04/jvm-e7-9a-84-e7-bc-96-e8-af-91-e6-97-b6-e5-a4-9a-e6-80-81-e4-b8-8e-e7-b1-bb-e5-9e-8b-e6-93-a6-e9-99-a4/">JVM的编译时多态与类型擦除</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>众所周知，java代码在编译过程中会进行类型擦除，类型擦除后泛型信息会丢失。可是，为什么在反射中还可以通过ParameterizedType的getActualTypeArguments方法来获得泛型信息呢。</p>
<p>首先，按照网上的说法，下面这两句所生成的字节码应该是一样的。但事实上,可以发现，他们所生成的字节码是不同的，区别就在Signature和LocalVariableTable中,这里标明了泛型的实际类型。</p>
<p>[java]<br>public static void print(Set&lt;Integer&gt; c) { } // LocalVariableTable中为Ljava/util/Set&lt;Ljava/lang/Integer;&gt;<br>public static void print(Set&lt;String&gt; c) { } // LocalVariableTable中为Ljava/util/Set&lt;Ljava/lang/String;&gt;<br>[/java]</p>
<p>看上去，泛型信息还在，可是为什么这两句放在一起会报错呢？</p>
<p>因为java采用的是<strong>编译时多态</strong>。java代码在编译过程中会尝试匹配所有同名方法，并且找到唯一符合条件的方法，然后将其签名写入字节码中，通过其签名来调用该方法。因此<strong>java中方法名可以相同，但是调用该方法的签名决不能相同</strong>。<br>在此例中上面两个方法生成的字节码虽然不同，但是在调用时所用的签名都是”print:(Ljava/util/List;)V”，因而无法区分这两个方法，所以不能多态。<br>正是因为编译时多态这种编译时分析确定签名，运行时根据签名直接调用的方式。导致下面这两句是完全可以执行的，原因就是虽然实参与形参不一致，但是实参与形参在忽略泛型后是一样的。<br>[java]<br>// 注意，这仅仅是个例子，由于编译器的检查功能所以这两句是无法编译通过的。因此需要通过反射的方式来实现。<br>// 当然，最简单的方式是将这两句分到两个类中用一些trick将两个class分别编译后直接运行，你可以发现代码是可以正常执行的，虽然直接编译它一定会报错。<br>print(new Set&lt;Integer&gt;());<br>public static void print(Set&lt;String&gt; c) { }<br>[/java]</p>
<p>由此可见，java中泛型擦除的确是存在的，运行时的基本可以认为泛型已经被完全擦除。但是，为什么ParameterizedType还是可以取得泛型信息呢？<br>答案是<strong>字节码</strong>。要知道，反射与JVM正常的运行是不同的，反射可以直接分析字节码，而字节码中有该类的签名以及变量的签名，从而可以分析出类或变量的泛型信息。</p>
<p>最后，通过查看字节码的反汇编结果可知以下情况中的泛型是可以通过反射获取的。<br>1：函数返回值中的泛型<br>2：函数参数中的泛型<br>3：类的field中的泛型<br>4：函数中局部变量的泛型「存于LocalVariableTypeTable中，仅用于调试，发布模式下不存在」</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s110-ef-bc-9a-e7-bd-91-e7-ab-99-e9-93-be-e6-8e-a5-e5-88-86-e6-9e-90-ef-bc-88-e4-b8-80-ef-bc-89" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/24/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s110-ef-bc-9a-e7-bd-91-e7-ab-99-e9-93-be-e6-8e-a5-e5-88-86-e6-9e-90-ef-bc-88-e4-b8-80-ef-bc-89/" class="article-date">
  	<time datetime="2015-04-24T01:37:49.000Z" itemprop="datePublished">2015-04-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/24/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s110-ef-bc-9a-e7-bd-91-e7-ab-99-e9-93-be-e6-8e-a5-e5-88-86-e6-9e-90-ef-bc-88-e4-b8-80-ef-bc-89/"> 数据分析S110：网站链接分析（一）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是网站链接分析的第一期，这一次的首要目的是从excle文件中提取出页面及页面之间的链接，其次就是完成初步的信息提取，即找出指定页面的链入链出情况，以及分析网站的链入链出。<br>[python]<br><strong>author</strong> = ‘sail’<br>db_filename = r’resource/link.db’<br>schema_filename = r’link.sql’<br>import sqlite3</p>
<p>def read_data():<br>    import os<br>    import pickle<br>    from multiprocessing import Pool</p>
<pre><code># 建立数据库及数据库，创建临时文件夹
conn = sqlite3.connect(db_filename)
print(&apos;Creating schema&apos;)
with open(schema_filename, &apos;rt&apos;) as f:
    schema = f.read()
conn.executescript(schema)
if not os.path.exists(r&amp;quot;resource/temp&amp;quot;):
    os.makedirs(r&amp;quot;resource/temp&amp;quot;)

#开启多进程读取excle文件，具体业务在__read_excle中
pool = Pool(processes=os.cpu_count())
results = pool.map(__read_excle, [(r&apos;resource/linkdata/&apos; + i, i) for i in os.listdir(r&apos;resource/linkdata/&apos;)])
pool.close()
pool.join()

#合并各进程返回的页面集，并插入数据库中
pages = set()
for i in results:
    pages.update(i)
conn.executemany(r&apos;INSERT INTO url(host,page,url) VALUES (?,?,?)&apos;,
                 (i.split(r&apos;//&apos;)[1][:-1].split(r&apos;/&apos;, 1) + [i] for i in pages))
conn.commit()

#取出url与id的对应关系
result = conn.execute(r&apos;SELECT id,url FROM url&apos;)
page_map = {}
for i in result:
    page_map[i[1]] = i[0]

#用取出的对应关系，将临时文件中的url指向转译为id指向后存入数据库
for parent, dirnames, filenames in os.walk(r&apos;resource/temp&apos;):
    for i in filenames:
        with open(parent + r&apos;/&apos; + i, &apos;rb&apos;) as f:
            page_link = pickle.load(f)
        os.remove(parent + r&apos;/&apos; + i)
        conn.executemany(r&apos;INSERT INTO link(source,target) VALUES (?,?)&apos;,
                         [(page_map[source], page_map[target]) for source in page_link for target in
                          page_link[source]])
conn.commit()
conn.close()
</code></pre><p>def __read_excle(file):<br>    import xlrd<br>    import pickle</p>
<pre><code>pages = set()
page_link = {}
table = xlrd.open_workbook(file[0]).sheets()[0]
for j in range(table.nrows):
    row = table.row_values(j)
    url = row[1]
    pages.add(url)
    page_link[url] = [i[1:-1] for i in row[2][1:-1].split(&apos;, &apos;)]
    for k in page_link[url]:
        pages.add(k)
with open(r&apos;resource/temp/&apos; + file[1] + &apos;.dat&apos;, &apos;wb&apos;) as f:
    pickle.dump(page_link, f)
return pages
</code></pre><p>def link_out(host, page):<br>    conn = sqlite3.connect(db_filename)<br>    result = conn.execute(‘SELECT url.url FROM link LEFT ‘<br>                          ‘JOIN url ON url.id=link.target WHERE source IN ‘<br>                          ‘(SELECT id FROM url WHERE host=? AND page=?)’, (host, page))<br>    return [i[0] for i in result]</p>
<p>def link_in(host, page):<br>    conn = sqlite3.connect(db_filename)<br>    result = conn.execute(‘SELECT url.url FROM link LEFT ‘<br>                          ‘JOIN url ON url.id=link.source WHERE target IN ‘<br>                          ‘(SELECT id FROM url WHERE host=? AND page=?)’, (host, page))<br>    return [i[0] for i in result]</p>
<p>def link_out_count(host):<br>    conn = sqlite3.connect(db_filename)<br>    result = conn.execute(‘SELECT url.host,count(*) FROM link LEFT ‘<br>                          ‘JOIN url ON url.id=link.target WHERE source IN ‘<br>                          ‘(SELECT id FROM url WHERE host=?) GROUP BY url.host’, (host,))<br>    return list(result)</p>
<p>def link_in_count(host):<br>    conn = sqlite3.connect(db_filename)<br>    result = conn.execute(‘SELECT url.host,count(*) FROM link LEFT ‘<br>                          ‘JOIN url ON url.id=link.source WHERE target IN ‘<br>                          ‘(SELECT id FROM url WHERE host=?) GROUP BY url.host’, (host,))<br>    return list(result)<br>[/python]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据分析/">数据分析</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s109-ef-bc-9a-e5-88-86-e7-b1-bb-e8-af-8d-e9-a2-91-e5-88-86-e6-9e-90" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/23/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s109-ef-bc-9a-e5-88-86-e7-b1-bb-e8-af-8d-e9-a2-91-e5-88-86-e6-9e-90/" class="article-date">
  	<time datetime="2015-04-23T09:04:57.000Z" itemprop="datePublished">2015-04-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/23/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s109-ef-bc-9a-e5-88-86-e7-b1-bb-e8-af-8d-e9-a2-91-e5-88-86-e6-9e-90/"> 数据分析S109：分类词频分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这次是在之前的词频分析的基础上，将词组根据词性分类后取出各种词性中的高频词。<br>[python]<br><strong>author</strong> = ‘sail’<br>import jieba<br>import jieba.analyse<br>import jieba.posseg as posseg<br>import dataio<br>from collections import *</p>
<p>db_filename = r’resource/chat.db’</p>
<p>def analyse(usrid=None, name=None):<br>    with open(r’resource/stopWordList.txt’, encoding=’utf-8’) as f:<br>        black_list = [i for i in f.read().split(‘\n’)]<br>    speak_list = dataio.someonechat(usrid, name)<br>    words = [i for i in jieba.posseg.cut(‘ ‘.join([i[‘contents’] for i in speak_list])) if i.word not in black_list]<br>    word_dict=defaultdict(list)<br>    for i in words:<br>        if i.flag != ‘eng’:<br>            i.flag = i.flag[0]<br>        word_dict[i.flag].append(i.word)<br>    print(Counter(word_dict[‘v’]).most_common(10))<br>    print(Counter(word_dict[‘n’]).most_common(10))<br>    print(Counter(word_dict[‘a’]).most_common(10))<br>[/python]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据分析/">数据分析</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s108-ef-bc-9a-e5-be-ae-e4-bf-a1-e6-96-87-e7-ab-a0-e5-af-86-e5-ba-a6-e7-9a-84-e5-bd-b1-e5-93-8d" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/17/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s108-ef-bc-9a-e5-be-ae-e4-bf-a1-e6-96-87-e7-ab-a0-e5-af-86-e5-ba-a6-e7-9a-84-e5-bd-b1-e5-93-8d/" class="article-date">
  	<time datetime="2015-04-17T08:12:42.000Z" itemprop="datePublished">2015-04-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/17/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s108-ef-bc-9a-e5-be-ae-e4-bf-a1-e6-96-87-e7-ab-a0-e5-af-86-e5-ba-a6-e7-9a-84-e5-bd-b1-e5-93-8d/">数据分析S108：微信文章密度的影响</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[python][/python]<br>def lcs(x, y):<br>    for i in range(min(len(y), len(x))):<br>        if x[i] != y[i]:<br>            break<br>    else:<br>        i += 1<br>    return x[:i]<br>df = pd.ExcelFile(r”resource/wxgzhdata.xlsx”).parse(u”3月”)<br>df = df.fillna(method=”pad”).dropna()<br>df.insert(0, ‘标题’, list(map(lambda x:x[:2],df[‘文章标题’])))<br>df.insert(len(df.columns), ‘距下一篇的天数’, df[‘文章标题’])<br>df = df.fillna(method=”pad”).dropna().set_index([‘文章标题’]).groupby(level =0).apply(lambda x: x.apply(<br>    lambda y: {1: lambda z: z[-1],2:lambda z:len(z), None: lambda z: z.groupby(type).sum().values[0]}<br>    <a href="y">{‘标题’: 1, ‘日期’: 1, ‘粉丝数’: 1,’距下一篇的天数’:2}.get(y.name)</a>)).sort([‘日期’])#.set_index([‘标题’])</p>
<h1 id="for-i-in-range-len-df-‘距下一篇的天数’-1-0-1"><a href="#for-i-in-range-len-df-‘距下一篇的天数’-1-0-1" class="headerlink" title="for i in range(len(df[‘距下一篇的天数’])-1,0,-1):"></a>for i in range(len(df[‘距下一篇的天数’])-1,0,-1):</h1><h1 id="df-‘距下一篇的天数’-i-df-‘距下一篇的天数’-i-1"><a href="#df-‘距下一篇的天数’-i-df-‘距下一篇的天数’-i-1" class="headerlink" title="df[‘距下一篇的天数’][i]=df[‘距下一篇的天数’][i-1]"></a>df[‘距下一篇的天数’][i]=df[‘距下一篇的天数’][i-1]</h1><p>day_list=list(df[‘距下一篇的天数’].values)<br>day_list.insert(0,np.nan)<br>day_list.pop(-1)<br>df.insert(len(df.columns),’距上一篇的天数’,value=day_list)</p>
<p>fields = [df.xs(‘总阅读人数’, axis=1), df.xs(‘初次打开阅读人数’, axis=1), df.xs(‘分享次数’, axis=1), df.xs(‘每日增粉人数’, axis=1),<br>          df.xs(‘粉丝数’, axis=1)]<br>to_percent = lambda x: (x * 100).round(1)<br>expressions = [(‘初次打开率’, lambda f: f[1] / f[4]), (‘分享率’, lambda f: f[2] / f[0]), (‘分享拉粉率’, lambda f: f[3] / f[2]),<br>               (‘增粉速率’, lambda f: f[3] / f[4]), ( ‘阅读涨粉率’, lambda f: f[3] / f[0]),<br>               (‘传播涨粉率’, lambda f: f[3] / (f[0] - f[1])), (‘二次传播率’, lambda f: (f[0] - f[1]) / f[0])]<br>old_field_count = len(df.columns)-2</p>
<h1 id="计算各字段的值，处理为percent后，依次插入datagrame中"><a href="#计算各字段的值，处理为percent后，依次插入datagrame中" class="headerlink" title="计算各字段的值，处理为percent后，依次插入datagrame中"></a>计算各字段的值，处理为percent后，依次插入datagrame中</h1><p>for i in enumerate(expressions, start=old_field_count):<br>    df.insert(i[0], i[1][0], (i[1]<a href="fields">1</a>).apply(to_percent))<br>df.set_index(‘距下一篇的天数’).dropna().groupby(level =0).mean().T[5:12].plot(kind=’barh’, figsize=(16, 9))<br>df.set_index(‘距上一篇的天数’).dropna().groupby(level =0).mean().T[5:12].plot(kind=’barh’, figsize=(16, 9))<br>groupby=df.groupby(lambda x:x[:2])<br>df=groupby.mean()<br>df.insert(5,’连载篇数’,groupby.count()[[‘标题’]])<br>df.set_index(‘连载篇数’).groupby(level=0).mean().T[5:12].plot(kind=’barh’, figsize=(16, 9))</p>
<h1 id="df-dropna-set-index-‘距下一篇的天数’"><a href="#df-dropna-set-index-‘距下一篇的天数’" class="headerlink" title="df.dropna().set_index(‘距下一篇的天数’)"></a>df.dropna().set_index(‘距下一篇的天数’)</h1><h1 id="df-plot-kind-’barh’-figsize-16-9"><a href="#df-plot-kind-’barh’-figsize-16-9" class="headerlink" title="df.plot(kind=’barh’, figsize=(16, 9))"></a>df.plot(kind=’barh’, figsize=(16, 9))</h1><p>#<br>from pylab import mpl<br>mpl.rcParams[‘font.sans-serif’] = [‘SimHei’]  # 指定默认字体<br>mpl.rcParams[‘axes.unicode_minus’] = False  # 解决保存图像是负号’-‘显示为方块的问题<br>plt.show()<br>[/python」</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据分析/">数据分析</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-java8-lambda-e8-a1-a8-e8-be-be-e5-bc-8f-e4-bd-93-e9-aa-8c" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/16/java8-lambda-e8-a1-a8-e8-be-be-e5-bc-8f-e4-bd-93-e9-aa-8c/" class="article-date">
  	<time datetime="2015-04-16T13:16:25.000Z" itemprop="datePublished">2015-04-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/16/java8-lambda-e8-a1-a8-e8-be-be-e5-bc-8f-e4-bd-93-e9-aa-8c/">java8 lambda表达式体验</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>java8在去年就发布了，其中包含了接口的默认实现，重复注解等许多新特性。其中，最令人关心的莫过于支持lambda表达式了。由于项目的历史问题，我没能在第一时间尝试java8所带来的lambda表达式。<br>今天群里面有人提到需要把一个数组中所有只出现了一次的字符串去除，剩下的输出。这个过程用js或是python都能够很容易的完成，并且代码非常简短，但是如果用java的话就会变得比较复杂。所以我尝试了用lambda来进行简化。<br>下面代码是首先将数组转化为stream后分组，然后通过values取得分组完毕的字符串。再转化为stream后通过filter筛去只出现过一次的字符串。此时得到的应该是一个双层的list，于是foreach两次对每个字符串使用println，打印输出。<br>[java]<br>String[] strings = {&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;};<br>Stream.of(strings).collect(Collectors.groupingBy((x) -&gt; x)).values().stream().filter((x) -&gt; x.size() != 1).forEach((x) -&gt; x.forEach(System.out::println));<br>[/java]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/java/">java</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s107-ef-bc-9a-e5-ae-8c-e6-88-90-e5-be-ae-e4-bf-a1-e8-bf-90-e8-90-a5-e8-af-84-e4-bc-b0-e6-a8-a1-e5-9e-8b" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/12/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s107-ef-bc-9a-e5-ae-8c-e6-88-90-e5-be-ae-e4-bf-a1-e8-bf-90-e8-90-a5-e8-af-84-e4-bc-b0-e6-a8-a1-e5-9e-8b/" class="article-date">
  	<time datetime="2015-04-12T08:15:55.000Z" itemprop="datePublished">2015-04-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/12/e6-95-b0-e6-8d-ae-e5-88-86-e6-9e-90s107-ef-bc-9a-e5-ae-8c-e6-88-90-e5-be-ae-e4-bf-a1-e8-bf-90-e8-90-a5-e8-af-84-e4-bc-b0-e6-a8-a1-e5-9e-8b/">数据分析S107：完成微信运营评估模型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[python]<br><strong>author</strong> = ‘sail’<br>import pandas as pd<br>from functools import reduce<br>import matplotlib.pyplot as plt</p>
<p>def analyse():</p>
<pre><code># 该函数用于将一个dataFrame合并为一条记录
# 入参x为一个dataFrame，调用tt对每个Series分别进行合并
def t(x):
    return x.apply(tt)

# 该函数用于对一个Series进行合并,入参x为一个Series
def tt(x):
    # 当x为标题时用reduce调用lcs函数求从字符串头开始的最长公共子串
    if x.name == &apos;标题&apos;:
        return reduce(lcs, x)
    # 当x为下列内容是取最后一项
    elif x.name in {&apos;日期&apos;, &apos;粉丝数&apos;}:
        return x[-1]
    # 其他情况时对将x中所有数据合并为一组求和，并返回该组求和结果
    else:
        return x.groupby(lambda x: 1).sum().values[0]

def lcs(x, y):
    for i in range(min(len(y), len(x))):
        if x[i] != y[i]:
            break
    else:
        i += 1
    return x[:i]

df = pd.ExcelFile(r&amp;quot;resource/wxgzhdata.xlsx&amp;quot;).parse(u&amp;quot;3月&amp;quot;)
df.insert(0, &apos;标题&apos;, df[&apos;文章标题&apos;])
df = df.fillna(method=&amp;quot;pad&amp;quot;).dropna().set_index([&apos;文章标题&apos;]).groupby(lambda x: x[:2]).apply(lambda x: x.apply(
    lambda y: {1: lambda z: reduce(lcs, z), 2: lambda z: z[-1], None: lambda z: z.groupby(type).sum().values[0]}
    [{&apos;标题&apos;: 1, &apos;日期&apos;: 2, &apos;粉丝数&apos;: 2}.get(y.name)](y))).set_index([&apos;标题&apos;])
# 下面为上句的另一种表达方式
# 用fillna填充nan
# df=df.fillna(method=&amp;quot;pad&amp;quot;)
# 将开头未能被pad填充的nan去除
# df=df.dropna()
# 将标题设为index以方便分组
# df=df.set_index([&apos;文章标题&apos;])
# 以标题的前两个字为基准分组
# df=df.groupby(lambda x: x[:2])
# 利用函数t对每个groupBy进行合并
# df=df.apply(t)
# 将各系列内文章标题的相同部分作为系列名称
# df=df.set_index([&apos;标题&apos;])

# 从dataframe中取得之后计算需要的Series
fields = [df.xs(&apos;总阅读人数&apos;, axis=1), df.xs(&apos;初次打开阅读人数&apos;, axis=1), df.xs(&apos;分享次数&apos;, axis=1), df.xs(&apos;每日增粉人数&apos;, axis=1),
          df.xs(&apos;粉丝数&apos;, axis=1)]
to_percent = lambda x: (x * 100).round(1)
# 各字段计算公式
expressions = [(&apos;初次打开率&apos;, lambda f: f[1] / f[4]), (&apos;分享率&apos;, lambda f: f[2] / f[0]), (&apos;分享拉粉率&apos;, lambda f: f[3] / f[2]),
               (&apos;增粉速率&apos;, lambda f: f[3] / f[4]), ( &apos;阅读涨粉率&apos;, lambda f: f[3] / f[0]),
               (&apos;传播涨粉率&apos;, lambda f: f[3] / (f[0] - f[1])), (&apos;二次传播率&apos;, lambda f: (f[0] - f[1]) / f[0])]
# 记录现有字段数量，用于下面计算新字段插入位置以及删除旧字段。
old_field_count = len(df.columns)
# 计算各字段的值，处理为percent后，依次插入datagrame中
for i in enumerate(expressions, start=old_field_count):
    df.insert(i[0], i[1][0], (i[1][1](fields)).apply(to_percent))
# 转制后将原始字段去除
df = df.T[old_field_count:]

df.plot(kind=&apos;barh&apos;, figsize=(16, 9))

from pylab import mpl
mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]  # 指定默认字体
mpl.rcParams[&apos;axes.unicode_minus&apos;] = False  # 解决保存图像是负号&apos;-&apos;显示为方块的问题
plt.show()
</code></pre><p>[/python]</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据分析/">数据分析</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-python-e5-ae-9e-e7-8e-b0lambda-switch-lambda-e7-bb-93-e6-9e-84-ef-bc-8c-e5-90-91lambda-e5-86-85-e6-8f-92-e5-85-a5-e5-88-86-e6-94-af-e7-bb-93-e6-9e-84" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/10/python-e5-ae-9e-e7-8e-b0lambda-switch-lambda-e7-bb-93-e6-9e-84-ef-bc-8c-e5-90-91lambda-e5-86-85-e6-8f-92-e5-85-a5-e5-88-86-e6-94-af-e7-bb-93-e6-9e-84/" class="article-date">
  	<time datetime="2015-04-10T12:44:09.000Z" itemprop="datePublished">2015-04-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/04/10/python-e5-ae-9e-e7-8e-b0lambda-switch-lambda-e7-bb-93-e6-9e-84-ef-bc-8c-e5-90-91lambda-e5-86-85-e6-8f-92-e5-85-a5-e5-88-86-e6-94-af-e7-bb-93-e6-9e-84/">python实现lambda-switch-lambda结构，向lambda内插入分支结构</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>python没有switch的问题由来已久，大家也用各种方式实现了switch语句。最常用的便是利用字典来实现。<br>而通过将单行带default功能的switch语句嵌入lambda中，可以实现根据key值不同，执行不同的分支代码的功能。</p>
<p>[python]</p>
<h1 id="1-这是这次的实验数据，目标是根据前面的符号对后面的数据进行操作，问号或其他无法识别的符号则视为直接返回该数字，分别执行-22-3-3-4-5-得到结果应该是-4-27-4-5"><a href="#1-这是这次的实验数据，目标是根据前面的符号对后面的数据进行操作，问号或其他无法识别的符号则视为直接返回该数字，分别执行-22-3-3-4-5-得到结果应该是-4-27-4-5" class="headerlink" title="1.这是这次的实验数据，目标是根据前面的符号对后面的数据进行操作，问号或其他无法识别的符号则视为直接返回该数字，分别执行 22, 3*3, -4, 5,得到结果应该是[4, 27, -4, 5]"></a>1.这是这次的实验数据，目标是根据前面的符号对后面的数据进行操作，问号或其他无法识别的符号则视为直接返回该数字，分别执行 2<em>2, 3*</em>3, -4, 5,得到结果应该是[4, 27, -4, 5]</h1><p>items = [(‘<em>‘, 2), (‘*</em>‘, 3), (‘-‘, 4), (‘?’, 5)]</p>
<h1 id="2-从简单的做起首先用map遍历item生成-‘‘-‘-‘-‘-‘-‘-’-的结果「我更喜欢列表解析，但是为了展示lambda-switch-lambda还是用map吧」。"><a href="#2-从简单的做起首先用map遍历item生成-‘‘-‘-‘-‘-‘-‘-’-的结果「我更喜欢列表解析，但是为了展示lambda-switch-lambda还是用map吧」。" class="headerlink" title="2.从简单的做起首先用map遍历item生成[‘‘, ‘*‘, ‘-‘, ‘?’]的结果「我更喜欢列表解析，但是为了展示lambda-switch-lambda还是用map吧」。"></a>2.从简单的做起首先用map遍历item生成[‘<em>‘, ‘*</em>‘, ‘-‘, ‘?’]的结果「我更喜欢列表解析，但是为了展示lambda-switch-lambda还是用map吧」。</h1><p>items = list(map(lambda x: x[0], items))</p>
<h1 id="3-然后加入带default功能的switch实现，得到将list转为-‘q’-‘w’-‘e’-‘r’"><a href="#3-然后加入带default功能的switch实现，得到将list转为-‘q’-‘w’-‘e’-‘r’" class="headerlink" title="3.然后加入带default功能的switch实现，得到将list转为[‘q’, ‘w’, ‘e’, ‘r’]"></a>3.然后加入带default功能的switch实现，得到将list转为[‘q’, ‘w’, ‘e’, ‘r’]</h1><p>items = list(map(lambda x: {‘<em>‘: ‘q’, ‘*</em>‘: ‘w’, ‘-‘: ‘e’}.get(x[0], ‘r’), items))</p>
<h1 id="4-最后将switch中的元素换成lambda并且在get之后执行，即可分别执行乘，幂，负和保持不变等分支，得到-4-27-4-5"><a href="#4-最后将switch中的元素换成lambda并且在get之后执行，即可分别执行乘，幂，负和保持不变等分支，得到-4-27-4-5" class="headerlink" title="4.最后将switch中的元素换成lambda并且在get之后执行，即可分别执行乘，幂，负和保持不变等分支，得到[4, 27, -4, 5]"></a>4.最后将switch中的元素换成lambda并且在get之后执行，即可分别执行乘，幂，负和保持不变等分支，得到[4, 27, -4, 5]</h1><p>items = list(map(lambda x: {‘<em>‘: lambda y: y </em> y, ‘<strong>‘: lambda y: y </strong> y, ‘-‘: lambda y: -y}.get(x[0], lambda y:y)(x[1]), items))</p>
<h1 id="5-这是另外一种实现方式，相比上一种多加了一个dict可以对key进行一次转化，合并同类作用的key，实现switch中多个case公用一个代码块的功能。"><a href="#5-这是另外一种实现方式，相比上一种多加了一个dict可以对key进行一次转化，合并同类作用的key，实现switch中多个case公用一个代码块的功能。" class="headerlink" title="5.这是另外一种实现方式，相比上一种多加了一个dict可以对key进行一次转化，合并同类作用的key，实现switch中多个case公用一个代码块的功能。"></a>5.这是另外一种实现方式，相比上一种多加了一个dict可以对key进行一次转化，合并同类作用的key，实现switch中多个case公用一个代码块的功能。</h1><h1 id="下面是把’‘和’-‘都视为乘，可以得到-4-9-4-5"><a href="#下面是把’‘和’-‘都视为乘，可以得到-4-9-4-5" class="headerlink" title="下面是把’‘和’*‘都视为乘，可以得到[4, 9, -4, 5]"></a>下面是把’<em>‘和’*</em>‘都视为乘，可以得到[4, 9, -4, 5]</h1><p>items = list(map(lambda x: {1: lambda y: y <em> y, 2: lambda y: y ** y, 3: lambda y: -y, None: lambda y: y}[{‘</em>‘: 1, ‘**’: 1, ‘-‘: 3}.get(x<a href="x[1]">0])</a>, items))</p>
<h1 id="6-这是将第5条加入的dict改为通过len对key进行预处理，以此类推，在主dict后的-中可以进行各种复杂操作，甚至再嵌入lambda，以实现更复杂的功能。"><a href="#6-这是将第5条加入的dict改为通过len对key进行预处理，以此类推，在主dict后的-中可以进行各种复杂操作，甚至再嵌入lambda，以实现更复杂的功能。" class="headerlink" title="6.这是将第5条加入的dict改为通过len对key进行预处理，以此类推，在主dict后的[]中可以进行各种复杂操作，甚至再嵌入lambda，以实现更复杂的功能。"></a>6.这是将第5条加入的dict改为通过len对key进行预处理，以此类推，在主dict后的[]中可以进行各种复杂操作，甚至再嵌入lambda，以实现更复杂的功能。</h1><h1 id="下面是根据key的长度，长度为1的执行乘操作，长度为2的执行幂操作，得到结果为-4-27-16-25"><a href="#下面是根据key的长度，长度为1的执行乘操作，长度为2的执行幂操作，得到结果为-4-27-16-25" class="headerlink" title="下面是根据key的长度，长度为1的执行乘操作，长度为2的执行幂操作，得到结果为[4, 27, 16, 25]"></a>下面是根据key的长度，长度为1的执行乘操作，长度为2的执行幂操作，得到结果为[4, 27, 16, 25]</h1><p>items = list(map(lambda x: {1: lambda y: y <em> y, 2: lambda y: y *</em> y, 3: lambda y: -y, None: lambda y: y}<a href="x[1]">len(x[0])</a>, items))<br>[/python]</p>
<p>利用该技巧，可以实现在lambda中加入分支语句，一定程度的改善了python中lambda的可用性。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/python/">python</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Sail
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>